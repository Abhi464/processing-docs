

<table width="650">
	<tr>
	<td>

	<p class="license">
    	This tutorial is “Extension 1” from <em><a href="https://mitpress.mit.edu/books/processing-0">Processing: A Programming Handbook for Visual Designers and Artists, Second Edition</a></em>, published by MIT Press. &copy; 2014 MIT Press. If you see any errors or have comments, please <a href="https://github.com/processing/processing-docs/issues?state=open">let us know</a>.
    </p>

	<h1 style="line-height: 0.7em;">Sound</h1>
	<h3 style="line-height: 0.7em;"><em>Text by R. Luke DuBois, code by Wilm Thoben</em></h3>

	<p class="txt">
		The history of music is, in many ways, the history of technology. From developments in the writing and transcription of music (notation) to the design of spaces for the performance of music (acoustics) to the creation of musical instruments, composers and musicians have availed themselves of advances in human understanding to perfect and advance their professions. Unsurprisingly, therefore, we find that in the machine age these same people found themselves first in line to take advantage of the new techniques and possibilities offered by electricity, telecommunications, and, in the last century, digital computers to leverage all of these systems to create new and expressive forms of sonic art. Indeed, the development of phonography (the ability to reproduce sound mechanically) has, by itself, had such a transformative effect on aural culture that it seems inconceivable now to step back to an age where sound could emanate only from its original source.<sup>1</sup> The ability to create, manipulate, and reproduce lossless sound by digital means is having, at the time of this writing, an equally revolutionary effect on how we listen. As a result, the artist today working with sound has not only a huge array of tools to work with, but also a medium exceptionally well suited to technological experimentation.
	</p>
 
	<h3>Music and sound programming in the arts</h3>
	
	<p class="txt">
		Thomas Edison’s 1857 invention of the phonograph and Nikola Tesla’s wireless radio demonstration of 1893 paved the way for what was to be a century of innovation in the electromechanical transmission and reproduction of sound. Emile Berliner’s gramophone record (1887) and the advent of AM radio broadcasting under Guglielmo Marconi (1922) democratized and popularized the consumption of music, initiating a process by which popular music quickly transformed from an art of minstrelsy into a commodified industry worth tens of billions of dollars worldwide.<sup>2</sup> New electronic musical instruments, from the large and impractical telharmonium to the simple and elegant theremin multiplied in tandem with recording and broadcast technologies and prefigured the synthesizers, sequencers, and samplers of today. Many composers of the time were, not unreasonably, entranced by the potential of these new mediums of transcription, transmission, and performance. Luigi Russolo, the futurist composer, wrote in his 1913 manifesto The Art of Noises of a futurist orchestra harnessing the power of mechanical noisemaking (and phonographic reproduction) to “liberate” sound from the tyranny of the merely musical. John Cage, in his 1937 monograph Credo: The Future of Music, wrote this elliptical doctrine:</p>
    	
    	<blockquote>
			The use of noise to make music will continue and increase until we reach a music produced through the aid of electrical instruments which will make available for musical purposes any and all sounds that can be heard. Photoelectric, film, and mechanical mediums for the synthetic production of music will be explored. Whereas, in the past, the point of disagreement has been between dissonance and consonance, it will be, in the immediate future, between noise and so-called musical sounds.<sup>3</sup>
		</blockquote>
		
	<p class="txt">
		The invention and wide adoption of magnetic tape as a medium for the recording of audio signals provided a breakthrough for composers waiting to compose purely with sound. In the early postwar period, the first electronic music studios flourished at radio stations in Paris (ORTF) and Cologne (WDR). The composers at the Paris studio, most notably Pierre Henry and Pierre Schaeffer, developed the early compositional technique of musique concrète, working directly with recordings of sound on phonographs and magnetic tape to construct compositions through a process akin to what we would now recognize as sampling. Schaeffer’s Étude aux chemins de fer (1948) and Henry and Schaeffer’s Symphonie pour un homme seul are classics of the genre. Meanwhile, in Cologne, composers such as Herbert Eimart and Karlheinz Stockhausen were investigating the use of electromechanical oscillators to produce pure sound waves that could be mixed and sequenced with a high degree of precision. This classic elektronische music was closely tied to the serial techniques of the contemporary modernist avant-garde, who were particularly well suited aesthetically to become crucial advocates for the formal quantification and automation offered by electronic and, later, computer music.<sup>4</sup> The Columbia-Princeton Electronic Music Center, founded by Vladimir Ussachevsky, Otto Luening, Milton Babbitt, and Roger Sessions in New York in 1957, staked its reputation on the massive RCA Mark II Sound Synthesizer, a room-sized machine capable of producing and sequencing electronically generated tones with an unprecedented degree of precision and control. In the realm of popular music, pioneering steps were taken in the field of recording engineering, such as the invention of multitrack tape recording by the guitarist Les Paul in 1954. This technology, enabling a single performer to “overdub” her/himself onto multiple individual “tracks” that could later be mixed into a composite, filled a crucial gap in the technology of recording and would empower the incredible boom in recording-studio experimentation that permanently cemented the commercial viability of the studio recording in popular music.
    </p>

    <p class="txt">
		Composers adopted digital computers slowly as a creative tool because of their initial lack of real-time responsiveness and intuitive interface. Although the first documented use of the computer to make music occurred in 1951 on the CSIRAC machine in Sydney, Australia, the genesis of most foundational technology in computer music as we know it today came when Max Mathews, a researcher at Bell Labs in the United States, developed a piece of software for the IBM 704 mainframe called MUSIC. In 1957, the MUSIC program rendered a 17-second composition by Newmann Guttmann called “In the Silver Scale”. Originally tasked with the development of human-comprehensible synthesized speech, Mathews developed a system for encoding and decoding sound waves digitally, as well as a system for designing and implementing digital audio processes computationally. His assumptions about these representational schemes are still largely in use and will be described later in this text. The advent of faster machines, computer music programming languages, and digital systems capable of real-time interactivity brought about a rapid transition from analog to computer technology for the creation and manipulation of sound, a process that by the 1990s was largely comprehensive.<sup>5</sup>
	</p>

	<p class="txt">
		Sound programmers (composers, sound artists, etc.) use computers for a variety of tasks in the creative process. Many artists use the computer as a tool for the algorithmic and computer-assisted composition of music that is then realized off-line. For Lejaren Hiller’s Illiac Suite for string quartet (1957), the composer ran an algorithm on the computer to generate notated instructions for live musicians to read and perform, much like any other piece of notated music. This computational approach to composition dovetails nicely with the aesthetic trends of twentieth-century musical modernism, including the controversial notion of the composer as “researcher,” best articulated by serialists such as Milton Babbitt and Pierre Boulez, the founder of IRCAM. This use of the computer to manipulate the symbolic language of music has proven indispensable to many artists, some of whom have successfully adopted techniques from computational research in artificial intelligence to attempt the modeling of preexisting musical styles and forms; for example, David Cope’s 5000 works... and Brad Garton’s Rough Raga Riffs use stochastic techniques from information theory such as Markov chains to simulate the music of J. S. Bach and the styles of Indian Carnatic sitar music, respectively. 
	</p>

	<p class="txt">
		If music can be thought of as a set of informatics to describe an organization of sound, the synthesis and manipulation of sound itself is the second category in which artists can exploit the power of computational systems. The use of the computer as a producer of synthesized sound liberates the artist from preconceived notions of instrumental capabilities and allows her/him to focus directly on the timbre of the sonic artifact, leading to the trope that computers allow us to make any sound we can imagine. Composers such as Jean-Claude Risset (The Bell Labs Catalogue), Iannis Xenakis (GENDYN3), and Barry Truax (Riverrun), have seen the computer as a crucial tool in investigating sound itself for compositional possibilities, be they imitative of real instruments (Risset), or formal studies in the stochastic arrangements of synthesized sound masses (Xenakis) using techniques culminating in the principles of granular synthesis (Truax). The computer also offers extensive possibilities for the assembly and manipulation of preexisting sound along the musique concrète model, though with all the alternatives a digital computer can offer. The compositional process of digital sampling, whether used in pop recordings (Brian Eno and David Byrne’s My Life in the Bush of Ghosts, Public Enemy’s Fear of a Black Planet) or conceptual compositions (John Oswald’s Plunderphonics, Chris Bailey’s Ow, My Head), is aided tremendously by the digital form sound can now take. Computers also enable the transcoding of an audio signal into representations that allow for radical reinvestigation, as in the time-stretching works of Leif Inge (9 Beet Stretch, a 24-hour “stretching” of Beethoven’s Ninth Symphony) and the time-lapse phonography of this text’s author (Messiah, a 5-minute “compression” of Handel’s Messiah).
	</p>

	<p class="txt">
		Artists working with sound will often combine the two approaches, allowing for the creation of generative works of sound art where the underlying structural system, as well as the sound generation and delivery, are computationally determined. Artists such as Michael Schumacher, Stephen Vitiello, Carl Stone, and Richard James (the Aphex Twin) all use this approach. Most excitingly, computers offer immense possibilities as actors and interactive agents in sonic performance, allowing performers to integrate algorithmic accompaniment (George Lewis), hyperinstrument design (Laetitia Sonami, Interface), and digital effects processing (Pauline Oliveros, Mari Kimura) into their repertoire.
	</p>

	<p class="txt">
		Now that we’ve talked a bit about the potential for sonic arts on the computer, we’ll investigate some of the specific underlying technologies that enable us to work with sound in the digital domain.
	</p>


	<h3>Sound and musical informatics</h3>
	
	<p class="txt">
		Simply put, we define sound as a vibration traveling through a medium (typically air) that we can perceive through our sense of hearing. Sound propagates as a longitudinal wave that alternately compresses and decompresses the molecules in the matter (e.g., air) through which it travels. As a result, we typically represent sound as a plot of pressure over time:
	</p>

	<!-- [Diagram 56-1] -->
	<img src="imgs/TK.svg" style= "width: 650px; height: 220px" class="tut">

	<p class="txt">
		This time-domain representation of sound provides an accurate portrayal of how sound works in the real world, and, as we shall see shortly, it is the most common representation of sound used in work with digitized audio. When we attempt a technical description of a sound wave, we can easily derive a few metrics to help us better understand what’s going on. In the first instance, by looking at the amount of displacement caused by the sound pressure wave, we can measure the amplitude of the sound. This can be measured on a scientific scale in pascals of pressure, but it is more typically quantified along a logarithmic scale of decibels. If the sound pressure wave repeats in a regular or periodic pattern, we can look at the wavelength of a single iteration of that pattern and from there derive the frequency of that wave. For example, if a sound traveling in a medium at 343 meters per second (the speed of sound in air at room temperature) contains a wave that repeats every half-meter, that sound has a frequency of 686 hertz, or cycles per second. The figure below shows a plot of a cello note sounding at 440 Hz; as a result, the periodic pattern of the waveform (demarcated with vertical lines) repeats every 2.27 ms:
	</p>

	<!-- [Diagram 56-2] -->
	<img src="imgs/TK.svg" style= "width: 650px; height: 220px" class="tut">

	<p class="txt">
		Typically, sounds occurring in the natural world contain many discrete frequency components. In noisy sounds, these frequencies may be completely unrelated to one another or grouped by a typology of boundaries (e.g., a snare drum may produce frequencies randomly spread between 200 and 800 hertz). In harmonic sounds, however, these frequencies are often spaced in integer ratios, such that a cello playing a note at 200 hertz will produce frequencies not only at the fundamental of 200, but at multiples of 200 up the harmonic series, i.e., at 400, 800, 1200, 1600, 2000, and so on. A male singer producing the same note will have the same frequency components in his voice, though in different proportions to the cello. The presence, absence, and relative strength of these harmonics (also called partials or overtones) provide what we perceive as the timbre of a sound.
	</p>

	<p class="txt">
		When a sound reaches our ears, an important sensory translation happens that is important to understand when working with audio. Just as light of different wavelengths and brightness excites different retinal receptors in your eyes to produce a color image, the cochlea of your inner ear contains an array of hair cells on the basilar membrane that are tuned to respond to different frequencies of sound. The inner ear contains hair cells that respond to frequencies spaced roughly between 20 and 20,000 hertz, though many of these hairs will gradually become desensitized with age or exposure to loud noise. These cells in turn send electrical signals via your auditory nerve into the auditory cortex of your brain, where they are parsed to create a frequency-domain image of the sound arriving in your ears:
	</p>

	<!-- [Diagram 56-3] -->
	<img src="imgs/TK.svg" style= "width: 650px; height: 220px" class="tut">

	<p class="txt">
		This representation of sound, as a discrete “frame” of frequencies and amplitudes independent of time, is more akin to the way in which we perceive our sonic environment than the raw pressure wave of the time domain. Jean-Baptiste-Joseph Fourier, a nineteenth-century French mathematician, developed the equations that allow us to translate a sound pressure wave (no matter how complex) into its constituent frequencies and amplitudes. This Fourier transform is an important tool in working with sound in the computer.
	</p>

	<p class="txt">
		This representation of sound, as a discrete “frame” of frequencies and amplitudes independent of time, is more akin to the way in which we perceive our sonic environment than the raw pressure wave of the time domain. Jean-Baptiste-Joseph Fourier, a nineteenth-century French mathematician, developed the equations that allow us to translate a sound pressure wave (no matter how complex) into its constituent frequencies and amplitudes. This Fourier transform is an important tool in working with sound in the computer.
	</p>

	<p class="txt">
		Our auditory system takes these streams of frequency and amplitude information from our two ears and uses them to construct an auditory “scene,” akin to the visual scene derived from the light reaching our retinas.6 Our brain analyzes the acoustic information based on a number of parameters such as onset time, stereo correlation, harmonic ratio, and complexity to parse out a number of acoustic sources that are then placed in a three-dimensional image representing what we hear. Many of the parameters that psychoacousticians believe we use to comprehend our sonic environment are similar to the grouping principles defined in Gestalt psychology.
	</p>

	<p class="txt">
		If we loosely define music as the organization and performance of sound, a new set of metrics reveals itself. While a comprehensive overview of music theory, Western or otherwise, is well beyond the scope of this text, it’s worth noting that there is a vocabulary for the description of music, akin to how we describe sound. Our system for perceiving loudness and pitch (useful “musical” equivalents to amplitude and frequency) work along a logarithmic scale, such that a tone at 100 hertz and a tone at 200 hertz are considered to be the same distance apart in terms of pitch as tones at 2000 and 4000 hertz. The distance between two sounds of doubling frequency is called the octave, and is a foundational principle upon which most culturally evolved theories of music rely. Most musical cultures then subdivide the octave into a set of pitches (e.g., 12 in the Western chromatic scale, 7 in the Indonesian pelog scale) that are then used in various collections (modes or keys). These pitches typically reflect some system of temperament or tuning, so that multiple musicians can play together; for example, the note A4 (the A above middle C) on the Western scale is usually calibrated to sound at 440 hertz in contemporary music.
	</p>


	<h3>Digital representation of sound and music</h3>

	<p class="txt">
		Sound typically enters the computer from the outside world (and vice versa) according to the time-domain representation explained earlier. Before it is digitized, the acoustic pressure wave of sound is first converted into an electromagnetic wave of sound that is a direct analog of the acoustic wave. This electrical signal is then fed to a piece of computer hardware called an analog-to-digital converter (ADC or A/D), which then digitizes the sound by sampling the amplitude of the pressure wave at a regular interval and quantifying the pressure readings numerically, passing them upstream in small packets, or vectors, to the main processor, where they can be stored or processed. Similarly, vectors of digital samples can be sent downstream from the computer to a hardware device called a digital-to-analog converter (DAC or D/A), which takes the numeric values and uses them to construct a smoothed-out electromagnetic pressure wave that can then be fed to a speaker or other device for playback:
	</p>

	<!-- [Diagram 56-4] -->
	<img src="imgs/TK.svg" style= "width: 650px; height: 220px" class="tut">

	<p class="txt">
		Most contemporary digital audio systems (soundcards, etc.) contain both A/D and D/A converters (often more than one of each, for stereo or multichannel sound recording and playback) and can use both simultaneously (so-called full duplex audio). The specific system of encoding and decoding audio using this methodology is called PCM (or pulse-code modulation); developed in 1937 by Alec Reeves, it is by far the most prevalent scheme in use today. 
	</p>

	<p class="txt">
		The speed at which audio signals are digitized is referred to as the sampling rate; it is the resolution that determines the highest frequency of sound that can be measured (equal to half the sampling rate, according to the Nyquist theorem). The numeric resolution of each sample in terms of computer storage space is called the bit depth; this value determines how many discrete levels of amplitude can be described by the digitized signal. The digital audio on a compact disc, for example, is digitized at 44,100 hertz with a 16-bit resolution, allowing for frequencies up to 22,050 hertz (i.e., just above the range of human hearing) with 65,536 (216) different levels of amplitude possible for each sample. Professional audio systems will go higher (96 or 192 kHz at 24- or 32-bit resolution) while industry telephony systems will go lower (e.g., 8,192 Hz at 8-bit). Digitized sound representing multiple acoustic sources (e.g., instruments) or destinations (e.g., speakers) is referred to as multi-channel audio. Monaural sound consists of, naturally, only one stream; stereo (two-stream) audio is standard on all contemporary computer audio hardware, and various types of surround-sound (five or seven streams of audio with one or two special channels for low frequencies) are becoming more and more common.
	</p>

	<p class="txt">
		Once in the computer, sound is stored using a variety of formats, both as sequences of PCM samples and in other representations. The two most common PCM sound file formats are the Audio Interchange File Format (AIFF) developed by Apple Computer and Electronic Arts and the WAV file format developed by Microsoft and IBM. Both formats are effectively equivalent in terms of quality and interoperability, and both are inherently lossless formats, containing the uncompressed PCM data from the digitized source. In recent years, compressed audio file formats have received a great deal of attention, most notably the MP3 (MPEG-1 Audio Layer 3), the Vorbis codec, and the Advanced Audio Coding (AAC) codec. Many of these “lossy” audio formats translate the sound into the frequency domain (using the Fourier transform or a related technique called Linear Predictive Coding) to package the sound in a way that allows compression choices to be made based on the human hearing model, by discarding perceptually irrelevant frequencies in the sound. Unlike the PCM formats outlined above, MP3 files are much harder to encode, manipulate, and process in real time, due to the extra step required to decompress and compress the audio into and out of the time domain.
	</p>



	<h3>Synthesis</h3>

	<p class="txt">
		Digital audio systems typically perform a variety of tasks by running processes in signal processing networks. Each node in the network typically performs a simple task that either generates or processes an audio signal. Most software for generating and manipulating sound on the computer follows this paradigm, originally outlined by Max Mathews as the unit generator model of computer music, where a map or function graph of a signal processing chain is executed for every sample (or vector of samples) passing through the system. A simple algorithm for synthesizing sound with a computer could be implemented using this paradigm with only three unit generators, described as follows.
	</p>

	<p class="txt">
		First, let’s assume we have a unit generator that generates a repeating sound waveform and has a controllable parameter for the frequency at which it repeats. We refer to this piece of code as an oscillator. Most typical digital oscillators work by playing back small tables or arrays of PCM audio data that outlines a specific waveform. These wavetables can contain incredibly simple patterns (e.g., a sine or square wave) or complex patterns from the outside world (e.g., a professionally recorded segment of a piano playing a single note). 
	</p>

	<p class="txt">
		If we play our oscillator directly (i.e., set its frequency to an audible value and route it directly to the D/A) we will hear a constant tone as the wavetable repeats over and over again. In order to attain a more nuanced and articulate sound, we may want to vary the volume of the oscillator over time so that it remains silent until we want a sound to occur. The oscillator will then increase in volume so that we can hear it. When we want the sound to silence again, we fade the oscillator down. Rather than rewriting the oscillator itself to accommodate instructions for volume control, we could design a second unit generator that takes a list of time and amplitude instructions and uses those to generate a so-called envelope, or ramp that changes over time. Our envelope generator generates an audio signal in the range of 0 to 1, though the sound from it is never experienced directly. Our third unit generator simply multiplies, sample per sample, the output of our oscillator with the output of our envelope generator. This amplifier code allows us to use our envelope ramp to dynamically change the volume of the oscillator, allowing the sound to fade in and out as we like.
	</p>

	<p class="txt">
		In a commercial synthesizer, further algorithms could be inserted into the signal network—for example, a filter that could shape the frequency content of the oscillator before it gets to the amplifier. Many synthesis algorithms depend on more than one oscillator, either in parallel (e.g., additive synthesis, in which you create a rich sound by adding many simple waveforms) or through modulation (e.g., frequency modulation, where one oscillator modulates the pitch of another).
	</p>



	<h3>Sampling</h3>

	<p class="txt">
		Rather than using a small waveform in computer memory as an oscillator, we could use a longer piece of recorded audio stored as an AIFF or WAV file on our computer’s hard disk. This sample could then be played back at varying rates, affecting its pitch. For example, playing back a sound at twice the speed at which it was recorded will result in its rising in pitch by an octave. Similarly, playing a sound at half speed will cause it to drop in pitch by an octave.
	</p>

	<!--<img src="imgs/TK.svg" style= "width: 650px; height: 220px" class="tut">

	<p class="txt">

	</p>
    -->

	<h3>Notes</h3>

	<p class="txt">
		<ol>
		<li>Douglas Kahn, <em>Noise, Water, Meat: A History of Sound in the Arts</em> (MIT Press, 2001),  p. 10.</li>
		<li>Paul Théberge, <em>Any Sound You Can Imagine: Making Music / Consuming Technology</em> (Wesleyan University Press, 1997),  p. 105.</li>
		<li>John Cage, “Credo: The Future of Music (1937),” in <em>John Cage: An Anthology</em>, edited by Richard Kostelanetz (Praeger, 1970),  p. 52.</li>
		<li>Joel Chadabe, <em>Electric Sound: The Past and Promise of Electronic Music</em> (Prentice Hall, 1996), p. 145.</li>
		<li>Curtis Roads, <em>The Computer Music Tutorial</em> (MIT Press, 1996), p. 43.</li>
		<li>Albert Bregman, <em>Auditory Scene Analysis</em> (MIT Press, 1994),  p. 215.</li>
		</ol>
	</p>



	<h3>Code</h3>

	<hr />

	<pre>
<span style="color: #666666;">/**</span>
<span style="color: #666666;">&nbsp;*&nbsp;Processing&nbsp;Sound&nbsp;Library,&nbsp;Example&nbsp;1</span>
<span style="color: #666666;">&nbsp;*&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;Five&nbsp;sine&nbsp;waves&nbsp;are&nbsp;layered&nbsp;to&nbsp;construct&nbsp;a&nbsp;cluster&nbsp;of&nbsp;frequencies.&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;This&nbsp;method&nbsp;is&nbsp;called&nbsp;additive&nbsp;synthesis.&nbsp;Use&nbsp;the&nbsp;mouse&nbsp;position&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;inside&nbsp;the&nbsp;display&nbsp;window&nbsp;to&nbsp;detune&nbsp;the&nbsp;cluster.</span>
<span style="color: #666666;">&nbsp;*/</span>

<span style="color: #33997E;">import</span> processing.sound.*;

SinOsc[]&nbsp;sineWaves;&nbsp;<span style="color: #666666;">// Array of sines</span>
<span style="color: #E2661A;">float</span>[] sineFreq; <span style="color: #666666;">// Array of frequencies</span>
<span style="color: #E2661A;">int</span> numSines = 5; <span style="color: #666666;">// Number of oscillators to use</span>

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {  
&nbsp;&nbsp;<span style="color: #006699;">size</span>(640, 360);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);

&nbsp;&nbsp;sineWaves&nbsp;=&nbsp;<span style="color: #33997E;">new</span> SinOsc[numSines]; <span style="color: #666666;">// Initialize the oscillators</span>
&nbsp;&nbsp;sineFreq&nbsp;=&nbsp;<span style="color: #33997E;">new</span> <span style="color: #E2661A;">float</span>[numSines]; <span style="color: #666666;">// Initialize array for Frequencies</span>

&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; numSines; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Calculate the amplitude for each oscillator</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> sineVolume = (1.0 / numSines) / (i + 1);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Create the oscillators</span>
&nbsp;&nbsp;&nbsp;&nbsp;sineWaves[i]&nbsp;=&nbsp;<span style="color: #33997E;">new</span> SinOsc(<span style="color: #33997E;">this</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Start Oscillators</span>
&nbsp;&nbsp;&nbsp;&nbsp;sineWaves[i].play();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Set the amplitudes for all oscillators</span>
&nbsp;&nbsp;&nbsp;&nbsp;sineWaves[i].amp(sineVolume);
&nbsp;&nbsp;}
}

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>draw</b></span>() {
&nbsp;&nbsp;<span style="color: #666666;">//Map mouseY from 0 to 1</span>
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> yoffset = <span style="color: #006699;">map</span>(<span style="color: #D94A7A;">mouseY</span>, 0, <span style="color: #D94A7A;">height</span>, 0, 1);
&nbsp;&nbsp;<span style="color: #666666;">//Map mouseY logarithmically to 150 - 1150 to create a base frequency range</span>
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> frequency = <span style="color: #006699;">pow</span>(1000, yoffset) + 150;
&nbsp;&nbsp;<span style="color: #666666;">//Use mouseX mapped from -0.5 to 0.5 as a detune argument</span>
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> detune = <span style="color: #006699;">map</span>(<span style="color: #D94A7A;">mouseX</span>, 0, <span style="color: #D94A7A;">width</span>, -0.5, 0.5);

&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; numSines; i++) { 
&nbsp;&nbsp;&nbsp;&nbsp;sineFreq[i]&nbsp;=&nbsp;frequency&nbsp;*&nbsp;(i&nbsp;+&nbsp;1&nbsp;*&nbsp;detune);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Set the frequencies for all oscillators</span>
&nbsp;&nbsp;&nbsp;&nbsp;sineWaves[i].freq(sineFreq[i]);
&nbsp;&nbsp;}
}
	</pre>

	<hr />

	<pre>
<span style="color: #666666;">/**</span>
<span style="color: #666666;">&nbsp;*&nbsp;Processing&nbsp;Sound&nbsp;Library,&nbsp;Example&nbsp;2</span>
<span style="color: #666666;">&nbsp;*&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;This&nbsp;sketch&nbsp;shows&nbsp;how&nbsp;to&nbsp;use&nbsp;envelopes&nbsp;and&nbsp;oscillators.&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;Envelopes&nbsp;describe&nbsp;to&nbsp;course&nbsp;of&nbsp;amplitude&nbsp;over&nbsp;time.&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;The&nbsp;Sound&nbsp;library&nbsp;provides&nbsp;an&nbsp;ASR&nbsp;envelope&nbsp;which&nbsp;stands&nbsp;for&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;attack,&nbsp;sustain,&nbsp;release.&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.________</span>
<span style="color: #666666;">&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---</span>
<span style="color: #666666;">&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---</span>
<span style="color: #666666;">&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;</span>
<span style="color: #666666;">&nbsp;*/</span>

<span style="color: #33997E;">import</span> processing.sound.*;

<span style="color: #666666;">//&nbsp;Oscillator&nbsp;and&nbsp;envelope&nbsp;</span>
TriOsc&nbsp;triOsc;
Env&nbsp;env;&nbsp;

<span style="color: #666666;">//&nbsp;Times&nbsp;and&nbsp;levels&nbsp;for&nbsp;the&nbsp;ASR&nbsp;envelope</span>
<span style="color: #E2661A;">float</span> attackTime = 0.001;
<span style="color: #E2661A;">float</span> sustainTime = 0.004;
<span style="color: #E2661A;">float</span> sustainLevel = 0.2;
<span style="color: #E2661A;">float</span> releaseTime = 0.2;

<span style="color: #666666;">//&nbsp;This&nbsp;is&nbsp;an&nbsp;octave&nbsp;in&nbsp;MIDI&nbsp;notes.</span>
<span style="color: #E2661A;">int</span>[] midiSequence = { 
&nbsp;&nbsp;60,&nbsp;61,&nbsp;62,&nbsp;63,&nbsp;64,&nbsp;65,&nbsp;66,&nbsp;67,&nbsp;68,&nbsp;69,&nbsp;70,&nbsp;71,&nbsp;72
};&nbsp;

<span style="color: #666666;">//&nbsp;Set&nbsp;the&nbsp;duration&nbsp;between&nbsp;the&nbsp;notes</span>
<span style="color: #E2661A;">int</span> duration = 200;
<span style="color: #666666;">//&nbsp;Set&nbsp;the&nbsp;note&nbsp;trigger</span>
<span style="color: #E2661A;">int</span> trigger = 0; 

<span style="color: #666666;">//&nbsp;An&nbsp;index&nbsp;to&nbsp;count&nbsp;up&nbsp;the&nbsp;notes</span>
<span style="color: #E2661A;">int</span> note = 0; 

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">size</span>(640, 360);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);

&nbsp;&nbsp;<span style="color: #666666;">// Create triangle wave and envelope </span>
&nbsp;&nbsp;triOsc&nbsp;=&nbsp;<span style="color: #33997E;">new</span> TriOsc(<span style="color: #33997E;">this</span>);
&nbsp;&nbsp;env&nbsp;&nbsp;=&nbsp;<span style="color: #33997E;">new</span> Env(<span style="color: #33997E;">this</span>);
}

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>draw</b></span>() { 

&nbsp;&nbsp;<span style="color: #666666;">// If value of trigger is equal to the computer clock and if not all </span>
&nbsp;&nbsp;<span style="color: #666666;">// notes have been played yet, the next note gets triggered.</span>
&nbsp;&nbsp;<span style="color: #669900;">if</span> ((<span style="color: #006699;">millis</span>() &gt; trigger) &amp;&amp; (note&lt;midiSequence.<span style="color: #33997E;">length</span>)) {

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// midiToFreq transforms the MIDI value into a frequency in Hz which we use </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">//to control the triangle oscillator with an amplitute of 0.8</span>
&nbsp;&nbsp;&nbsp;&nbsp;triOsc.play(midiToFreq(midiSequence[note]),&nbsp;0.8);

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// The envelope gets triggered with the oscillator as input and the times and </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// levels we defined earlier</span>
&nbsp;&nbsp;&nbsp;&nbsp;env.play(triOsc,&nbsp;attackTime,&nbsp;sustainTime,&nbsp;sustainLevel,&nbsp;releaseTime);

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Create the new trigger according to predefined durations and speed</span>
&nbsp;&nbsp;&nbsp;&nbsp;trigger&nbsp;=&nbsp;<span style="color: #006699;">millis</span>() + duration;

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Advance by one note in the midiSequence;</span>
&nbsp;&nbsp;&nbsp;&nbsp;note++;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Loop the sequence</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #669900;">if</span> (note == 12) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
}&nbsp;

<span style="color: #666666;">//&nbsp;This&nbsp;function&nbsp;calculates&nbsp;the&nbsp;respective&nbsp;frequency&nbsp;of&nbsp;a&nbsp;MIDI&nbsp;note</span>
<span style="color: #E2661A;">float</span> midiToFreq(<span style="color: #E2661A;">int</span> note) {
&nbsp;&nbsp;<span style="color: #33997E;">return</span> (<span style="color: #006699;">pow</span>(2, ((note-69)/12.0)))*440;
}

</pre>

	<hr />

<pre>
<span style="color: #666666;">/**</span>
<span style="color: #666666;">&nbsp;*&nbsp;Processing&nbsp;Sound&nbsp;Library,&nbsp;Example&nbsp;3</span>
<span style="color: #666666;">&nbsp;*&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;This&nbsp;example&nbsp;shows&nbsp;how&nbsp;to&nbsp;make&nbsp;a&nbsp;simple&nbsp;sampler&nbsp;and&nbsp;sequencer&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;with&nbsp;the&nbsp;Sound&nbsp;library.&nbsp;In&nbsp;this&nbsp;sketch,&nbsp;five&nbsp;different&nbsp;samples&nbsp;are&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;loaded&nbsp;and&nbsp;played&nbsp;back&nbsp;at&nbsp;different&nbsp;pitches,&nbsp;in&nbsp;this&nbsp;case&nbsp;five&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;different&nbsp;octaves.&nbsp;The&nbsp;sequencer&nbsp;triggers&nbsp;an&nbsp;event&nbsp;every&nbsp;200-1000&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;milliseconds&nbsp;randomly.&nbsp;Each&nbsp;time&nbsp;a&nbsp;sound&nbsp;is&nbsp;played&nbsp;a&nbsp;colored&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;rect&nbsp;with&nbsp;a&nbsp;random&nbsp;color&nbsp;is&nbsp;displayed.</span>
<span style="color: #666666;">&nbsp;*/</span>

<span style="color: #33997E;">import</span> processing.sound.*;

SoundFile[]&nbsp;files;

<span style="color: #666666;">//&nbsp;Create&nbsp;an&nbsp;array&nbsp;of&nbsp;values&nbsp;which&nbsp;represent&nbsp;the&nbsp;octaves.&nbsp;</span>
<span style="color: #666666;">//&nbsp;1.0&nbsp;is&nbsp;playback&nbsp;at&nbsp;normal&nbsp;speed,&nbsp;0.5&nbsp;is&nbsp;half&nbsp;and&nbsp;therefore&nbsp;</span>
<span style="color: #666666;">//&nbsp;one&nbsp;octave&nbsp;down.&nbsp;2.0&nbsp;is&nbsp;double&nbsp;so&nbsp;one&nbsp;octave&nbsp;up.</span>
<span style="color: #E2661A;">float</span>[] octave = { 
&nbsp;&nbsp;0.25,&nbsp;0.5,&nbsp;1.0,&nbsp;2.0,&nbsp;4.0
};

<span style="color: #666666;">//&nbsp;The&nbsp;playSound&nbsp;array&nbsp;is&nbsp;defining&nbsp;how&nbsp;many&nbsp;samples&nbsp;will&nbsp;be&nbsp;</span>
<span style="color: #666666;">//&nbsp;played&nbsp;at&nbsp;each&nbsp;trigger&nbsp;event</span>
<span style="color: #E2661A;">int</span>[] playSound = { 
&nbsp;&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1
};

<span style="color: #666666;">//&nbsp;The&nbsp;trigger&nbsp;is&nbsp;an&nbsp;integer&nbsp;number&nbsp;in&nbsp;milliseconds&nbsp;so&nbsp;we&nbsp;</span>
<span style="color: #666666;">//&nbsp;can&nbsp;schedule&nbsp;new&nbsp;events&nbsp;in&nbsp;the&nbsp;draw&nbsp;loop</span>
<span style="color: #E2661A;">int</span> trigger=0;

<span style="color: #666666;">//&nbsp;This&nbsp;array&nbsp;holds&nbsp;the&nbsp;pixel&nbsp;positions&nbsp;of&nbsp;the&nbsp;rectangles&nbsp;</span>
<span style="color: #666666;">//&nbsp;that&nbsp;are&nbsp;drawn&nbsp;each&nbsp;event</span>
<span style="color: #E2661A;">int</span>[] posx = {
&nbsp;&nbsp;0,&nbsp;128,&nbsp;256,&nbsp;384,&nbsp;512
};


<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">size</span>(640, 360);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);

&nbsp;&nbsp;<span style="color: #666666;">// Create an array of 5 empty soundfiles</span>
&nbsp;&nbsp;files&nbsp;=&nbsp;<span style="color: #33997E;">new</span> SoundFile[5];

&nbsp;&nbsp;<span style="color: #666666;">// Load 5 soundfiles from a folder in a for loop. By naming </span>
&nbsp;&nbsp;<span style="color: #666666;">// the files 1., 2., 3., [...], n.aif it is easy to iterate </span>
&nbsp;&nbsp;<span style="color: #666666;">// through the folder and load all files in one line of code.</span>
&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; files.<span style="color: #33997E;">length</span>; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;files[i]&nbsp;=&nbsp;<span style="color: #33997E;">new</span> SoundFile(<span style="color: #33997E;">this</span>, (i+1) + <span style="color: #7D4793;">&quot;.aif&quot;</span>);
&nbsp;&nbsp;}
}

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>draw</b></span>() {

&nbsp;&nbsp;<span style="color: #666666;">// If the determined trigger moment in time matches up with </span>
&nbsp;&nbsp;<span style="color: #666666;">// the computer clock events get triggered.</span>
&nbsp;&nbsp;<span style="color: #669900;">if</span> (<span style="color: #006699;">millis</span>() &gt; trigger) {

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Redraw the background every time to erase old rects</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// By iterating through the playSound array we check for </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// 1 or 0, 1 plays a sound and draws a rect, for 0 nothing happens</span>

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; files.<span style="color: #33997E;">length</span>; i++) {      
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Check which indexes are 1 and 0.</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #669900;">if</span> (playSound[i] == 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> rate;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Choose a random color and get set to noStroke()</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">fill</span>(<span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(255)), <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(255)), <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(255)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">noStroke</span>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Draw the rect in the positions we defined earlier in posx</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">rect</span>(posx[i], 50, 128, 260);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Choose a random index of the octave array</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rate&nbsp;=&nbsp;octave[<span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(0, 5))];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Play the soundfile from the array with the respective </span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// rate and loop set to false</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files[i].play(rate,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Renew the indexes of playSound so that at the next event </span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// the order is different and randomized.</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playSound[i]&nbsp;=&nbsp;<span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(0, 2));
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Create a new triggertime in the future, with a random offset </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// between 200 and 1000 milliseconds</span>
&nbsp;&nbsp;&nbsp;&nbsp;trigger&nbsp;=&nbsp;<span style="color: #006699;">millis</span>() + <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(200, 1000));
&nbsp;&nbsp;}
}

</pre>

	<hr />

<pre>
<span style="color: #666666;">/**</span>
<span style="color: #666666;">&nbsp;*&nbsp;Processing&nbsp;Sound&nbsp;Library,&nbsp;Example&nbsp;4</span>
<span style="color: #666666;">&nbsp;*&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;Five&nbsp;soundfiles&nbsp;are&nbsp;mapped&nbsp;to&nbsp;the&nbsp;numbers&nbsp;on&nbsp;the&nbsp;keyboard.&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;Numbers&nbsp;1-5&nbsp;are&nbsp;played&nbsp;back&nbsp;an&nbsp;octave&nbsp;lower&nbsp;and&nbsp;numbers</span>
<span style="color: #666666;">&nbsp;*&nbsp;6-0&nbsp;an&nbsp;octave&nbsp;higher.</span>
<span style="color: #666666;">&nbsp;*/</span>

<span style="color: #33997E;">import</span> processing.sound.*;

AudioDevice&nbsp;device;
SoundFile[]&nbsp;file;

<span style="color: #E2661A;">int</span> red, green, blue;

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">size</span>(640, 360);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);

&nbsp;&nbsp;<span style="color: #666666;">// Create an AudioDevice with low buffer size </span>
&nbsp;&nbsp;<span style="color: #666666;">// and create an array containing 5 empty soundfiles</span>
&nbsp;&nbsp;device&nbsp;=&nbsp;<span style="color: #33997E;">new</span> AudioDevice(<span style="color: #33997E;">this</span>, 48000, 32);
&nbsp;&nbsp;file&nbsp;=&nbsp;<span style="color: #33997E;">new</span> SoundFile[5];

&nbsp;&nbsp;<span style="color: #666666;">// Load 5 soundfiles from a folder in a for loop. </span>
&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; file.<span style="color: #33997E;">length</span>; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;file[i]&nbsp;=&nbsp;<span style="color: #33997E;">new</span> SoundFile(<span style="color: #33997E;">this</span>, (i+1) + <span style="color: #7D4793;">&quot;.aif&quot;</span>);
&nbsp;&nbsp;}
}

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>draw</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">background</span>(red, green, blue);
}

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>keyPressed</b></span>() {
&nbsp;&nbsp;<span style="color: #666666;">// Set a random background color each time you hit then number keys</span>
&nbsp;&nbsp;red=<span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(255));
&nbsp;&nbsp;green=<span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(255));
&nbsp;&nbsp;blue=<span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(255));

&nbsp;&nbsp;<span style="color: #666666;">// Assign a sound to each number on your keyboard. 1-5 play at</span>
&nbsp;&nbsp;<span style="color: #666666;">// an octave below the original pitch of the file, 6-0 play at</span>
&nbsp;&nbsp;<span style="color: #666666;">// an octave above.</span>
&nbsp;&nbsp;<span style="color: #669900;">switch</span>(<span style="color: #D94A7A;">key</span>) {
&nbsp;&nbsp;<span style="color: #33997E;">case</span> <span style="color: #7D4793;">&apos;1&apos;</span>:
&nbsp;&nbsp;&nbsp;&nbsp;file[0].play(0.5,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #33997E;">break</span>;
&nbsp;&nbsp;<span style="color: #33997E;">case</span> <span style="color: #7D4793;">&apos;2&apos;</span>:
&nbsp;&nbsp;&nbsp;&nbsp;file[1].play(0.5,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #33997E;">break</span>;
&nbsp;&nbsp;<span style="color: #33997E;">case</span> <span style="color: #7D4793;">&apos;3&apos;</span>:
&nbsp;&nbsp;&nbsp;&nbsp;file[2].play(0.5,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #33997E;">break</span>;
&nbsp;&nbsp;<span style="color: #33997E;">case</span> <span style="color: #7D4793;">&apos;4&apos;</span>:
&nbsp;&nbsp;&nbsp;&nbsp;file[3].play(0.5,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #33997E;">break</span>;
&nbsp;&nbsp;<span style="color: #33997E;">case</span> <span style="color: #7D4793;">&apos;5&apos;</span>:
&nbsp;&nbsp;&nbsp;&nbsp;file[4].play(0.5,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #33997E;">break</span>;
&nbsp;&nbsp;<span style="color: #33997E;">case</span> <span style="color: #7D4793;">&apos;6&apos;</span>:
&nbsp;&nbsp;&nbsp;&nbsp;file[0].play(2.0,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #33997E;">break</span>;
&nbsp;&nbsp;<span style="color: #33997E;">case</span> <span style="color: #7D4793;">&apos;7&apos;</span>:
&nbsp;&nbsp;&nbsp;&nbsp;file[1].play(2.0,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #33997E;">break</span>;
&nbsp;&nbsp;<span style="color: #33997E;">case</span> <span style="color: #7D4793;">&apos;8&apos;</span>:
&nbsp;&nbsp;&nbsp;&nbsp;file[2].play(2.0,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #33997E;">break</span>;
&nbsp;&nbsp;<span style="color: #33997E;">case</span> <span style="color: #7D4793;">&apos;9&apos;</span>:
&nbsp;&nbsp;&nbsp;&nbsp;file[3].play(2.0,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #33997E;">break</span>;
&nbsp;&nbsp;<span style="color: #33997E;">case</span> <span style="color: #7D4793;">&apos;0&apos;</span>:
&nbsp;&nbsp;&nbsp;&nbsp;file[4].play(2.0,&nbsp;1.0);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #33997E;">break</span>;
&nbsp;&nbsp;}
}

</pre>

	<hr />

<pre>
<span style="color: #666666;">/**</span>
<span style="color: #666666;">&nbsp;*&nbsp;Processing&nbsp;Sound&nbsp;Library,&nbsp;Example&nbsp;5</span>
<span style="color: #666666;">&nbsp;*&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;This&nbsp;sketch&nbsp;shows&nbsp;how&nbsp;to&nbsp;use&nbsp;the&nbsp;FFT&nbsp;class&nbsp;to&nbsp;analyze&nbsp;a&nbsp;stream&nbsp;&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;of&nbsp;sound.&nbsp;Change&nbsp;the&nbsp;variable&nbsp;bands&nbsp;to&nbsp;get&nbsp;more&nbsp;or&nbsp;less&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;spectral&nbsp;bands&nbsp;to&nbsp;work&nbsp;with.&nbsp;The&nbsp;smooth_factor&nbsp;variable&nbsp;determines&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;how&nbsp;much&nbsp;the&nbsp;signal&nbsp;will&nbsp;be&nbsp;smoothed&nbsp;on&nbsp;a&nbsp;scale&nbsp;form&nbsp;0-1.</span>
<span style="color: #666666;">&nbsp;*/</span>

<span style="color: #33997E;">import</span> processing.sound.*;

<span style="color: #666666;">//&nbsp;Declare&nbsp;the&nbsp;processing&nbsp;sound&nbsp;variables&nbsp;</span>
SoundFile&nbsp;sample;
FFT&nbsp;fft;
AudioDevice&nbsp;device;

<span style="color: #666666;">//&nbsp;Declare&nbsp;a&nbsp;scaling&nbsp;factor</span>
<span style="color: #E2661A;">int</span> scale = 5;

<span style="color: #666666;">//&nbsp;Define&nbsp;how&nbsp;many&nbsp;FFT&nbsp;bands&nbsp;we&nbsp;want</span>
<span style="color: #E2661A;">int</span> bands = 128;

<span style="color: #666666;">//&nbsp;declare&nbsp;a&nbsp;drawing&nbsp;variable&nbsp;for&nbsp;calculating&nbsp;rect&nbsp;width</span>
<span style="color: #E2661A;">float</span> r_width;

<span style="color: #666666;">//&nbsp;Create&nbsp;a&nbsp;smoothing&nbsp;vector</span>
<span style="color: #E2661A;">float</span>[] sum = <span style="color: #33997E;">new</span> <span style="color: #E2661A;">float</span>[bands];

<span style="color: #666666;">//&nbsp;Create&nbsp;a&nbsp;smoothing&nbsp;factor</span>
<span style="color: #E2661A;">float</span> smooth_factor = 0.2;

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">size</span>(640, 360);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);

&nbsp;&nbsp;<span style="color: #666666;">// If the Buffersize is larger than the FFT Size, the FFT will fail</span>
&nbsp;&nbsp;<span style="color: #666666;">// so we set Buffersize equal to bands</span>
&nbsp;&nbsp;device&nbsp;=&nbsp;<span style="color: #33997E;">new</span> AudioDevice(<span style="color: #33997E;">this</span>, 44000, bands);

&nbsp;&nbsp;<span style="color: #666666;">// Calculate the width of the rects depending on how many bands we have</span>
&nbsp;&nbsp;r_width&nbsp;=&nbsp;<span style="color: #D94A7A;">width</span>/<span style="color: #006699;">float</span>(bands);

&nbsp;&nbsp;<span style="color: #666666;">// Load and play a soundfile and loop it. This has to be called </span>
&nbsp;&nbsp;<span style="color: #666666;">// before the FFT is created.</span>
&nbsp;&nbsp;sample&nbsp;=&nbsp;<span style="color: #33997E;">new</span> SoundFile(<span style="color: #33997E;">this</span>, <span style="color: #7D4793;">&quot;beat.aiff&quot;</span>);
&nbsp;&nbsp;sample.<span style="color: #006699;">loop</span>();

&nbsp;&nbsp;<span style="color: #666666;">// Create and patch the FFT analyzer</span>
&nbsp;&nbsp;fft&nbsp;=&nbsp;<span style="color: #33997E;">new</span> FFT(<span style="color: #33997E;">this</span>, bands);
&nbsp;&nbsp;fft.input(sample);
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>draw</b></span>() {
&nbsp;&nbsp;<span style="color: #666666;">// Set background color, noStroke and fill color</span>
&nbsp;&nbsp;<span style="color: #006699;">background</span>(204);
&nbsp;&nbsp;<span style="color: #006699;">fill</span>(0, 0, 255);
&nbsp;&nbsp;<span style="color: #006699;">noStroke</span>();

&nbsp;&nbsp;fft.analyze();
&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; bands; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Smooth the FFT data by smoothing factor</span>
&nbsp;&nbsp;&nbsp;&nbsp;sum[i]&nbsp;+=&nbsp;(fft.spectrum[i]&nbsp;-&nbsp;sum[i])&nbsp;*&nbsp;smooth_factor;

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #666666;">// Draw the rects with a scale factor</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">rect</span>( i*r_width, <span style="color: #D94A7A;">height</span>, r_width, -sum[i]*<span style="color: #D94A7A;">height</span>*scale );
&nbsp;&nbsp;}
}

</pre>

	<hr />

<pre>
<span style="color: #666666;">/**</span>
<span style="color: #666666;">&nbsp;*&nbsp;Processing&nbsp;Sound&nbsp;Library,&nbsp;Example&nbsp;6</span>
<span style="color: #666666;">&nbsp;*&nbsp;</span>
<span style="color: #666666;">&nbsp;*&nbsp;This&nbsp;sketch&nbsp;shows&nbsp;how&nbsp;to&nbsp;use&nbsp;the&nbsp;Amplitude&nbsp;class&nbsp;to&nbsp;analyze&nbsp;a</span>
<span style="color: #666666;">&nbsp;*&nbsp;stream&nbsp;of&nbsp;sound.&nbsp;In&nbsp;this&nbsp;case&nbsp;a&nbsp;sample&nbsp;is&nbsp;analyzed.&nbsp;The&nbsp;smoothFactor</span>
<span style="color: #666666;">&nbsp;*&nbsp;variable&nbsp;determines&nbsp;how&nbsp;much&nbsp;the&nbsp;signal&nbsp;will&nbsp;be&nbsp;smoothed&nbsp;on&nbsp;a&nbsp;scale</span>
<span style="color: #666666;">&nbsp;*&nbsp;from&nbsp;0&nbsp;-&nbsp;1.</span>
<span style="color: #666666;">&nbsp;*/</span>

<span style="color: #33997E;">import</span> processing.sound.*;

<span style="color: #666666;">//&nbsp;Declare&nbsp;the&nbsp;processing&nbsp;sound&nbsp;variables&nbsp;</span>
SoundFile&nbsp;sample;
Amplitude&nbsp;rms;

<span style="color: #666666;">//&nbsp;Declare&nbsp;a&nbsp;scaling&nbsp;factor</span>
<span style="color: #E2661A;">float</span> scale = 5.0;

<span style="color: #666666;">//&nbsp;Declare&nbsp;a&nbsp;smooth&nbsp;factor</span>
<span style="color: #E2661A;">float</span> smoothFactor = 0.25;

<span style="color: #666666;">//&nbsp;Used&nbsp;for&nbsp;smoothing</span>
<span style="color: #E2661A;">float</span> sum;

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">size</span>(640, 360);

&nbsp;&nbsp;<span style="color: #666666;">//Load and play a soundfile and loop it</span>
&nbsp;&nbsp;sample&nbsp;=&nbsp;<span style="color: #33997E;">new</span> SoundFile(<span style="color: #33997E;">this</span>, <span style="color: #7D4793;">&quot;beat.aiff&quot;</span>);
&nbsp;&nbsp;sample.<span style="color: #006699;">loop</span>();

&nbsp;&nbsp;<span style="color: #666666;">// Create and patch the rms tracker</span>
&nbsp;&nbsp;rms&nbsp;=&nbsp;<span style="color: #33997E;">new</span> Amplitude(<span style="color: #33997E;">this</span>);
&nbsp;&nbsp;rms.input(sample);
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>draw</b></span>() {
&nbsp;&nbsp;<span style="color: #666666;">// Set background color, noStroke and fill color</span>
&nbsp;&nbsp;<span style="color: #006699;">background</span>(0, 0, 255);
&nbsp;&nbsp;<span style="color: #006699;">noStroke</span>();
&nbsp;&nbsp;<span style="color: #006699;">fill</span>(255, 0, 150);

&nbsp;&nbsp;<span style="color: #666666;">// Smooth the rms data by smoothing factor</span>
&nbsp;&nbsp;sum&nbsp;+=&nbsp;(rms.analyze()&nbsp;-&nbsp;sum)&nbsp;*&nbsp;smoothFactor;&nbsp;&nbsp;

&nbsp;&nbsp;<span style="color: #666666;">// rms.analyze() return a value between 0 and 1. It&apos;s</span>
&nbsp;&nbsp;<span style="color: #666666;">// scaled to height/2 and then multiplied by a scale factor</span>
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> rmsScaled = sum * (<span style="color: #D94A7A;">height</span>/2) * scale;

&nbsp;&nbsp;<span style="color: #666666;">// Draw an ellipse at a size based on the audio analysis</span>
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(<span style="color: #D94A7A;">width</span>/2, <span style="color: #D94A7A;">height</span>/2, rmsScaled, rmsScaled);
}

</pre>

	<hr />

	</td></tr>
 </table>