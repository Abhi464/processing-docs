<h1 style="line-height: 0.7em;">Sound</h1>
<h3 style="line-height: 0.7em;"><em>Text by R. Luke DuBois, code by Wilm Thoben</em></h3>

<table width="650">
	<tr>
	<td>

    <p class="license">
    	This tutorial is Extension 1 from the second edition of <em><a href="https://mitpress.mit.edu/books/processing-0">Processing: A Programming Handbook for Visual Designers and Artists</a></em>, published by MIT Press. Copyright 2014 MIT Press. This tutorial is for Processing version 2.0+. If you see any errors or have comments, please <a href="https://github.com/processing/processing-docs/issues?state=open">let us know</a>.
    </p>

	<p class="txt">
		The history of music is, in many ways, the history of technology. From developments in the writing and transcription of music (notation) to the design of spaces for the performance of music (acoustics) to the creation of musical instruments, composers and musicians have availed themselves of advances in human understanding to perfect and advance their professions. Unsurprisingly, therefore, we find that in the machine age these same people found themselves first in line to take advantage of the new techniques and possibilities offered by electricity, telecommunications, and, in the last century, digital computers to leverage all of these systems to create new and expressive forms of sonic art. Indeed, the development of phonography (the ability to reproduce sound mechanically) has, by itself, had such a transformative effect on aural culture that it seems inconceivable now to step back to an age where sound could emanate only from its original source.1 The ability to create, manipulate, and reproduce lossless sound by digital means is having, at the time of this writing, an equally revolutionary effect on how we listen. As a result, the artist today working with sound has not only a huge array of tools to work with, but also a medium exceptionally well suited to technological experimentation.
	</p>
 
	<h3>Music and sound programming in the arts</h3>
	
	<p class="txt">
		Thomas Edison’s 1857 invention of the phonograph and Nikola Tesla’s wireless radio demonstration of 1893 paved the way for what was to be a century of innovation in the electromechanical transmission and reproduction of sound. Emile Berliner’s gramophone record (1887) and the advent of AM radio broadcasting under Guglielmo Marconi (1922) democratized and popularized the consumption of music, initiating a process by which popular music quickly transformed from an art of minstrelsy into a commodified industry worth tens of billions of dollars worldwide.2 New electronic musical instruments, from the large and impractical telharmonium to the simple and elegant theremin multiplied in tandem with recording and broadcast technologies and prefigured the synthesizers, sequencers, and samplers of today. Many composers of the time were, not unreasonably, entranced by the potential of these new mediums of transcription, transmission, and performance. Luigi Russolo, the futurist composer, wrote in his 1913 manifesto The Art of Noises of a futurist orchestra harnessing the power of mechanical noisemaking (and phonographic reproduction) to “liberate” sound from the tyranny of the merely musical. John Cage, in his 1937 monograph Credo: The Future of Music, wrote this elliptical doctrine:</p>
    	
    	<blockquote>
			The use of noise to make music will continue and increase until we reach a music produced through the aid of electrical instruments which will make available for musical purposes any and all sounds that can be heard. Photoelectric, film, and mechanical mediums for the synthetic production of music will be explored. Whereas, in the past, the point of disagreement has been between dissonance and consonance, it will be, in the immediate future, between noise and so-called musical sounds.3
		</blockquote>
		
	<p class="txt">
		The invention and wide adoption of magnetic tape as a medium for the recording of audio signals provided a breakthrough for composers waiting to compose purely with sound. In the early postwar period, the first electronic music studios flourished at radio stations in Paris (ORTF) and Cologne (WDR). The composers at the Paris studio, most notably Pierre Henry and Pierre Schaeffer, developed the early compositional technique of musique concrète, working directly with recordings of sound on phonographs and magnetic tape to construct compositions through a process akin to what we would now recognize as sampling. Schaeffer’s Étude aux chemins de fer (1948) and Henry and Schaeffer’s Symphonie pour un homme seul are classics of the genre. Meanwhile, in Cologne, composers such as Herbert Eimart and Karlheinz Stockhausen were investigating the use of electromechanical oscillators to produce pure sound waves that could be mixed and sequenced with a high degree of precision. This classic elektronische music was closely tied to the serial techniques of the contemporary modernist avant-garde, who were particularly well suited aesthetically to become crucial advocates for the formal quantification and automation offered by electronic and, later, computer music.4 The Columbia-Princeton Electronic Music Center, founded by Vladimir Ussachevsky, Otto Luening, Milton Babbitt, and Roger Sessions in New York in 1957, staked its reputation on the massive RCA Mark II Sound Synthesizer, a room-sized machine capable of producing and sequencing electronically generated tones with an unprecedented degree of precision and control. In the realm of popular music, pioneering steps were taken in the field of recording engineering, such as the invention of multitrack tape recording by the guitarist Les Paul in 1954. This technology, enabling a single performer to “overdub” her/himself onto multiple individual “tracks” that could later be mixed into a composite, filled a crucial gap in the technology of recording and would empower the incredible boom in recording-studio experimentation that permanently cemented the commercial viability of the studio recording in popular music.
    </p>

    <p class="txt">
		Composers adopted digital computers slowly as a creative tool because of their initial lack of real-time responsiveness and intuitive interface. Although the first documented use of the computer to make music occurred in 1951 on the CSIRAC machine in Sydney, Australia, the genesis of most foundational technology in computer music as we know it today came when Max Mathews, a researcher at Bell Labs in the United States, developed a piece of software for the IBM 704 mainframe called MUSIC. In 1957, the MUSIC program rendered a 17-second composition by Newmann Guttmann called “In the Silver Scale”. Originally tasked with the development of human-comprehensible synthesized speech, Mathews developed a system for encoding and decoding sound waves digitally, as well as a system for designing and implementing digital audio processes computationally. His assumptions about these representational schemes are still largely in use and will be described later in this text. The advent of faster machines, computer music programming languages, and digital systems capable of real-time interactivity brought about a rapid transition from analog to computer technology for the creation and manipulation of sound, a process that by the 1990s was largely comprehensive.5
	</p>

	<p class="txt">
		Sound programmers (composers, sound artists, etc.) use computers for a variety of tasks in the creative process. Many artists use the computer as a tool for the algorithmic and computer-assisted composition of music that is then realized off-line. For Lejaren Hiller’s Illiac Suite for string quartet (1957), the composer ran an algorithm on the computer to generate notated instructions for live musicians to read and perform, much like any other piece of notated music. This computational approach to composition dovetails nicely with the aesthetic trends of twentieth-century musical modernism, including the controversial notion of the composer as “researcher,” best articulated by serialists such as Milton Babbitt and Pierre Boulez, the founder of IRCAM. This use of the computer to manipulate the symbolic language of music has proven indispensable to many artists, some of whom have successfully adopted techniques from computational research in artificial intelligence to attempt the modeling of preexisting musical styles and forms; for example, David Cope’s 5000 works... and Brad Garton’s Rough Raga Riffs use stochastic techniques from information theory such as Markov chains to simulate the music of J. S. Bach and the styles of Indian Carnatic sitar music, respectively. 
	</p>

	<p class="txt">
		If music can be thought of as a set of informatics to describe an organization of sound, the synthesis and manipulation of sound itself is the second category in which artists can exploit the power of computational systems. The use of the computer as a producer of synthesized sound liberates the artist from preconceived notions of instrumental capabilities and allows her/him to focus directly on the timbre of the sonic artifact, leading to the trope that computers allow us to make any sound we can imagine. Composers such as Jean-Claude Risset (The Bell Labs Catalogue), Iannis Xenakis (GENDYN3), and Barry Truax (Riverrun), have seen the computer as a crucial tool in investigating sound itself for compositional possibilities, be they imitative of real instruments (Risset), or formal studies in the stochastic arrangements of synthesized sound masses (Xenakis) using techniques culminating in the principles of granular synthesis (Truax). The computer also offers extensive possibilities for the assembly and manipulation of preexisting sound along the musique concrète model, though with all the alternatives a digital computer can offer. The compositional process of digital sampling, whether used in pop recordings (Brian Eno and David Byrne’s My Life in the Bush of Ghosts, Public Enemy’s Fear of a Black Planet) or conceptual compositions (John Oswald’s Plunderphonics, Chris Bailey’s Ow, My Head), is aided tremendously by the digital form sound can now take. Computers also enable the transcoding of an audio signal into representations that allow for radical reinvestigation, as in the time-stretching works of Leif Inge (9 Beet Stretch, a 24-hour “stretching” of Beethoven’s Ninth Symphony) and the time-lapse phonography of this text’s author (Messiah, a 5-minute “compression” of Handel’s Messiah).
	</p>

	<p class="txt">
		Artists working with sound will often combine the two approaches, allowing for the creation of generative works of sound art where the underlying structural system, as well as the sound generation and delivery, are computationally determined. Artists such as Michael Schumacher, Stephen Vitiello, Carl Stone, and Richard James (the Aphex Twin) all use this approach. Most excitingly, computers offer immense possibilities as actors and interactive agents in sonic performance, allowing performers to integrate algorithmic accompaniment (George Lewis), hyperinstrument design (Laetitia Sonami, Interface), and digital effects processing (Pauline Oliveros, Mari Kimura) into their repertoire.
	</p>

	<p class="txt">
		Now that we’ve talked a bit about the potential for sonic arts on the computer, we’ll investigate some of the specific underlying technologies that enable us to work with sound in the digital domain.
	</p>


	<h3>Sound and musical informatics</h3>
	
	<p class="txt">
		Simply put, we define sound as a vibration traveling through a medium (typically air) that we can perceive through our sense of hearing. Sound propagates as a longitudinal wave that alternately compresses and decompresses the molecules in the matter (e.g., air) through which it travels. As a result, we typically represent sound as a plot of pressure over time:
	</p>

	<img src="imgs/fg39-14.svg" style= "width: 650px; height: 220px" class="tut">

	<p class="txt">
		This time-domain representation of sound provides an accurate portrayal of how sound works in the real world, and, as we shall see shortly, it is the most common representation of sound used in work with digitized audio. When we attempt a technical description of a sound wave, we can easily derive a few metrics to help us better understand what’s going on. In the first instance, by looking at the amount of displacement caused by the sound pressure wave, we can measure the amplitude of the sound. This can be measured on a scientific scale in pascals of pressure, but it is more typically quantified along a logarithmic scale of decibels. If the sound pressure wave repeats in a regular or periodic pattern, we can look at the wavelength of a single iteration of that pattern and from there derive the frequency of that wave. For example, if a sound traveling in a medium at 343 meters per second (the speed of sound in air at room temperature) contains a wave that repeats every half-meter, that sound has a frequency of 686 hertz, or cycles per second. The figure below shows a plot of a cello note sounding at 440 Hz; as a result, the periodic pattern of the waveform (demarcated with vertical lines) repeats every 2.27 ms:
	</p>



<br />
Notes
<br />
1. Dan O’Sullivan and Tom Igoe, <em>Physical Computing: Sensing and Controlling the Physical World with Computers</em> (Thomson Course Technology PTR, 2004), p. TC
</p>
<br />
<br />
<p>
<h3>Code</h3>
<p>
To run these examples, unlike the other examples in this book, you will need additional equipment. They require either a Wiring (wiring.org.co) or Arduino (www.arduino.cc) board and the following:
<br /> 
<br /> 
    <ul>
<li>USB cable (used to send data between board and computer)</li>
<li>9–15V 1000mA power supply or 9V battery</li>
<li>22-gauge solid core wire (get different colors)</li>
<li>Breadboard</li>
<li>Switch</li>
<li>Resistors  (10K ohm for the switch circuits, 330 ohm for the LEDs, 1K ohm for the photoresistor)</li>
<li>LEDs</li>
<li>Servo motor (Futaba or Hi-Tech)</li>
<li>DC motor (a generic DC motor like the ones in toy cars)</li>
<li>L293D or SN754410 H-Bridge Integrated Circuit</li>
<li>Wire cutters</li>
<li>Wire strippers</li>
<li>Needlenose pliers </li>
    </ul> 
<br /> 
This equipment can be purchased from an electronics store such as Radio Shack or from an online vendor.
<br />
<br />
	Each example presents two programs: code for the I/O board and code for Processing. Diagrams and breadboard illustrations for the examples are presented side by side in this tutorial to reinforce the connections between the two representations. Learning to translate a circuit diagram into a physical circuit is one of the most difficult challenges when starting to work with electronics. 
<br />
<br />
	The Wiring or Arduino software environment is necessary to program each board. These environments are built on top of the Processing environment, but they have special features for uploading code to the board and monitoring serial communication. Both can be downloaded at no cost from their respective websites and both are available for Linux, Macintosh, and Windows. 
<br />
<br />
	The examples that follow assume the I/O board is connected to your computer and serial communication is working. Before working with these examples, get one of the simple Serial library examples included with Processing to work. For the most up-to-date information and troubleshooting tips, read the Serial reference on the Processing website: www.processing.org/reference/libraries. The Wiring and Arduino websites have additional information.
<br />
<br /> 
<hr />
<br /> 
<br />
<em>Example 1A:  Switch (Wiring/Arduino)</em>
<br /> 
<br /> 
<img src="imgs/fg39-13.svg" style= "width: 650px; height: 220px">
<br /> 
<pre>
// Code for sensing a switch status and writing the value to the serial port

int switchPin = 4;  		       // Switch connected to pin 4 
 
void setup() { 
  pinMode(switchPin, INPUT);  	       // Set pin 0 as an input 
  Serial.begin(9600);         	       // Start serial communication at 9600 bps 
} 
 
void loop() { 
  if (digitalRead(switchPin) == HIGH) {  // If switch is ON, 
    Serial.print(1, BYTE);               // send 1 to Processing
  } else {                               // If the switch is not ON,
    Serial.print(0, BYTE);               // send 0 to Processing 
  } 
  delay(100);                            // Wait 100 milliseconds 
} 
</pre>
<br /> 
<br />
<em>Example 1B:  Switch (Processing)</em>
<pre>
// Read data from the serial port and change the color of a rectangle 
// when a switch connected to the board is pressed and released
 
import processing.serial.*; 
 
Serial port;                             // Create object from Serial class 
int val;                                 // Data received from the serial port 
 
void setup() { 
  size(200, 200); 
  frameRate(10); 
  // Open the port that the board is connected to and use the same speed (9600 bps) 
  port = new Serial(this, 9600); 
} 

void draw() { 
  if (0 &lt; port.available()) {            // If data is available,
    val = port.read();                   // read it and store it in val
  } 
  background(255);                       // Set background to white
  if (val == 0)  {                       // If the serial value is 0,
    fill(0);                             // set fill to black
  } else {                               // If the serial value is not 0,
    fill(204);                           // set fill to light gray
  } 
  rect(50, 50, 100, 100);
} 
</pre>
<br />
<hr />
<br />
<em>Example 2A:  Light sensor (Wiring/Arduino)</em>
<br />
<br /> 
<img src="imgs/fg39-14.svg" style= "width: 650px; height: 220px">
<br /> 
<pre>
// Code to read an analog value and write it to the serial port

int val; 
int inputPin = 0;                // Set the input to analog in pin 0
 
void setup() { 
  Serial.begin(9600);            // Start serial communication at 9600 bps 
} 
 
void loop() { 
  val = analogRead(inputPin)/4;  // Read analog input pin, put in range 0 to 255
  Serial.print(val, BYTE);       // Send the value
  delay(100);                    // Wait 100ms for next reading 
}
</pre>
<br /> 
<br /> 
<em>Example 2B:  Light sensor (Processing)</em>
<pre>
// Read data from the serial port and assign it to a variable. Set the fill a 
// rectangle on the screen using the value read from a light sensor connected 
// to the Wiring or Arduino board 
 
import processing.serial.*; 
 
Serial port;  			       // Create object from Serial class
int val;      			       // Data received from the serial port 
 
void setup() { 
  size(200, 200); 
  noStroke(); 
  frameRate(10);                // Run 10 frames per second
  // Open the port that the board is connected to and use the same speed (9600 bps) 
  port = new Serial(this, 9600); 
} 

void draw() { 
  if (0 &lt; port.available()) {    // If data is available to read,
    val = port.read();           // read it and store it in val
  } 
  background(204);               // Clear background
  fill(val);                     // Set fill color with the value read
  rect(50, 50, 100, 100);        // Draw square
} 
</pre>
<br />
<hr />
<br />
<em>Example 3A: Turning a light on and off</em>
<br /> 
<br /> 
<img src="imgs/fg39-15.svg" style= "width: 650px; height: 220px">
<br /> 
<pre>
// Read data from the serial and turn ON or OFF a light depending on the value
 
char val;                          // Data received from the serial port 
int ledPin = 4;                    // Set the pin to digital I/O 4

void setup() { 
  pinMode(ledPin, OUTPUT);         // Set pin as OUTPUT 
  Serial.begin(9600);              // Start serial communication at 9600 bps 
} 
 
void loop() { 
  if (Serial.available()) {        // If data is available to read, 
    val = Serial.read();           // read it and store it in val 
  } 
  if (val == 'H') {                // If H was received
    digitalWrite(ledPin, HIGH);    // turn the LED on 
  } else { 
    digitalWrite(ledPin, LOW);     // Otherwise turn it OFF
  } 
  delay(100);                      // Wait 100 milliseconds for next reading 
} 
</pre>
<br /> 
<br /> 
<em>Example 3B: Turning a light on and off (Processing)</em>
<pre>
// Check if the mouse is over a rectangle and write the status to the serial port

import processing.serial.*; 
 
Serial port;                       // Create object from Serial class
 
void setup() { 
  size(200, 200); 
  noStroke(); 
  frameRate(10); 
  // Open the port that the board is connected to and use the same speed (9600 bps)
  port = new Serial(this, 9600); 
} 
 
void draw() { 
  background(255); 
  if (mouseOverRect() == true)  {  // If mouse is over square,
    fill(204);                     // change color and  
    port.write('H');               // send an H to indicate mouse is over square 
  } else {                         // If mouse is not over square,
    fill(0);                       // change color and
    port.write('L');               // send an L otherwise
  } 
  rect(50, 50, 100, 100);          // Draw a square 
} 


boolean mouseOverRect() {        // Test if mouse is over square 
  return ((mouseX >= 50) &amp;&amp; (mouseX <= 150) && (mouseY >= 50) &amp;&amp; (mouseY <= 150)); 
} 
</pre>
<br />
<hr />
<br />
<em>Example 4A: Controlling a servomotor(Wiring/Arduino)</em>
<br /> 
<br /> 
<img src="imgs/fg39-16.svg" style= "width: 650px; height: 297px">
<br /> 
<pre>
// Read data from the serial port and set the position of a servomotor 
// according to the value

Servo myservo;                   // Create servo object to control a servo
int servoPin = 4;                // Connect yellow servo wire to digital I/O pin 4 
int val = 0;                     // Data received from the serial port

void setup() {
  myservo.attach(servoPin);      // Attach the servo to the PWM pin
  Serial.begin(9600);    	       // Start serial communication at 9600 bps
}

void loop() {
  if (Serial.available()) {      // If data is available to read,
    val = Serial.read();         // read it and store it in val 
  } 
  myservo.write(val);            // Set the servo position
  delay(15);                     // Wait for the servo to get there
}
</pre>
<br /> 
<br /> 
<em>Example 4B: Controlling a servomotor (Processing)</em>
<pre>
// Write data to the serial port according to the mouseX value

import processing.serial.*;
 
Serial port;                          // Create object from Serial class
float mx = 0.0;

void setup() { 
  size(200, 200); 
  noStroke(); 
  frameRate(10); 
  // Open the port that the board is connected to and use the same speed (9600 bps) 
  port = new Serial(this, 9600); 
} 

void draw() {   
  background(0);			    // Clear background 
  fill(204);				    // Set fill color 
  rect(40, height/2-15, 120, 25);	    // Draw square

  float dif = mouseX - mx;
  if (abs(dif) > 1.0) {
    mx += dif/4.0;
  }
  mx = constrain(mx, 50, 149);                // Keeps marker on the screen
  noStroke();
  fill(255);
  rect(50, (height/2)-5, 100, 5);  
  fill(204, 102, 0);
  
  rect(mx-2, height/2-5, 4, 5);               // Draw the position marker
  int angle = int(map(mx, 50, 149, 0, 180));  // Scale the value to the range 0-180
  //print(angle + " ");	                    // Print the current angle (debug)
  port.write(angle);	                    // Write the angle to the serial port
}
</pre>
<br />
<hr />
<br />
<em>Example 5A: Turning a DC Motor on and off (Wiring/Arduino)</em>
<br /> 
<br /> 
<img src="imgs/fg39-17.svg" style= "width: 650px; height: 369px">
<br /> 
<br /> 
<pre>
// Read data from the serial and turn a DC motor on or off according to the value

char val;                              // Data received from the serial port
int motorpin = 0;     // Wiring: Connect L293D Pin En1 connected to Pin PWM 0          
// int motorpin = 9;  // Arduino: Connect L293D Pin En1 to Pin PWM 9
 
void setup() { 
  Serial.begin(9600);                  // Start serial communication at 9600 bps 
} 
 
void loop() { 
  if (Serial.available()) {            // If data is available,  
    val = Serial.read();               // read it and store it in val</em> 
  } 
  if (val == 'H') {                    // If 'H' was received, 
    analogWrite(motorpin, 125);        // turn the motor on at medium speed 
  } else { 			             // If 'H' was not received
    analogWrite(motorpin, 0);          // turn the motor off 
  } 
  delay(100);                          // Wait 100 milliseconds for next reading
}
</pre>
<br /> 
<br /> 
<em>Example 5B: Turning a DC motor on and off (Processing)</em>
<pre>
// Write data to the serial port according to the status of a button controlled 
// by the mouse 

import processing.serial.*;

Serial port;                           // Create serial port object 
boolean rectOver = false;      	
int rectX, rectY;                      // Position of square button
int rectSize = 100;                    // Diameter of rect
color rectColor;
boolean buttonOn = false;              // Status of the button
void setup() {
  size(200, 200); 
  noStroke(); 
  frameRate(10);
  rectColor = color(100);
  rectX = width/2 - rectSize/2;
  rectY = height/2 - rectSize/2;
  // Open the port that the board is connected to and use the same speed (9600 bps)
  port = new Serial(this, 9600); 
} 

void draw() {   
  update(mouseX, mouseY);
  background(0);                 // Clear background to black
  fill(rectColor);            	         
  rect(rectX, rectY, rectSize, rectSize);  
} 

void update(int x, int y) {
  if (overRect(rectX, rectY, rectSize, rectSize) == true) {
    rectOver = true;
  } else {
    rectOver = false;
  }
}

void mouseReleased() {
  if (rectOver == true) {
    if (buttonOn == true) {
      rectColor = color(100);
      buttonOn = false;
      port.write('L');           // Send an L to indicate button is OFF
    } else {
      rectColor = color(180);
      buttonOn = true;
      port.write('H');           // Send an H to indicate button is ON 
    }
  }
}

boolean overRect(int x, int y, int width, int height) {
  if ((mouseX >= x) &amp;&amp; (mouseX &lt;= x+width) &amp;&amp; 
      (mouseY >= y) &amp;&amp; (mouseY &lt;= y+height)) {
    return true;
  } else {
    return false;
  }
}
</pre>
</p>
<hr />
<br />
<br />
<!--
<p>
<h3>Resources</h3>
<em>Vendors and manufacturers</em>
<br />
<a href="http://www.acroname.com">Acroname</a>. Robotics components distributor and BrainStem creator.
<br />
<a href="http://www.allelectronics.com">All Electronics</a>. Surplus electronics distributor.
<br /> 
<a href="http://www.analog.com">Analog Devices</a>. Electronics components (sensors, A/D converters, etc.) manufacturer.
<br /> 
<a href="http://www.arduino.cc">Arduino</a>. Prototyping toolkit.
<br /> 
<a href="http://www.digikey.com">Digi-Key</a>. Large electronics parts distributor.
<br /> 
<a href="http://www.jameco.com">Jameco</a>. Large electronics parts distributor.
<br /> 
<a href="http://mindstorms.lego.com">LEGO Mindstorms</a>. Programmable electronics from LEGO.
<br /> 
<a href="http://www.mcmaster.com">McMaster-Carr</a>. Extensive selection of hardware and construction supplies. 
<br /> 
<a href="http://www.microchip.com">Microchip</a>. Creator of PICmicro microcontrollers.
<br /> 
<a href="http://www.servocity.com">Servocity</a>. Servomotor distributor.
<br /> 
<a href="http://www.smallparts.com">Small Parts</a>. Hardware for researchers and developers.
<br /> 
<a href="http://www.solarbotics.com">Solarbotics</a>. Distributor for solar-powered robotics kits and components.
<br /> 
<a href="http://www.sparkfun.com">Spark Fun Electronics</a>.
<br /> 
<a href="http://wiring.org.co">Wiring</a>. Prototyping environment and toolkit.
<br />
<br /> 
<em>Online resources</em>
<br /> 
Buxton, Bill. <a href="http://www.billbuxton.com/InputSources.html">List of input devices</a>.
<br />
Igoe, Tom. <a href="http://tigoe.net/pcomp">Physical computing resources</a>.
<br />
<a href="http://www.findchips.com">FindChips</a>. Electronic components search engine.
<br />
<a href="http://www.instructables.com">Instructables</a>. Step-by-step instructions for building projects.
<br />
Haque, Usman, and Adam Somlai-Fischer. <a href="http://lowtech.propositions.org.uk">Low-tech sensors and actuators</a>.
<br />
<a href="http://www.makezine.com">Make magazine</a>. Do-it-yourself technology.
<br />
<a href="http://www.opencircuits.com">Open Circuits</a>. Wiki for electronics projects, components, and techniques.
<br />
O’Sullivan, Dan. <a href="http://itp.nyu.edu/~dbo3/physical/physical.html">Physical computing resources</a>.
<br />
<a href="http://en.wikipedia.org/wiki/RS-232">RS-232 Serial</a>. Data protocol description.
<br />
<br />
<em>Texts</em>
<br />
Banzi, Massimo. <em>Getting Started with Arduino</em>. Make, 2011.
<br />
Burnham, Jack. <em>Beyond Modern Sculpture</em>. George Braziller, 1968.
<br />
Horowitz, Paul, and Winfield Hill. <em>The Art of Electronics</em>. Second edition. Cambridge University Press, 1989.
<br />
Hultén, K. G. Pontus. <em>The Machine: As Seen at the End of the Mechanical Age</em>. The Museum of Modern Art, 1968.
<br />
Fraden, Jacob. <em>Handbook of Modern Sensors: Physics, Designs, and Applications</em>. Springer-Verlag, 1996.
<br /> 
Igoe, Tom. <em>Making Things Talk: Using Sensors, Networks, and Arduino to See, Hear, and Feel Your World.</em> Make, 2011.
<br /> 
Margolis, Michael. <em>Arduino Cookbook</em>. O’Reilly Media, 2011.
<br />
Mims, Forrest M. III. <em>Getting Started in Electronics</em>. Second edition. Radio Shack, 1998.
<br /> 
Mims, Forrest M. III. <em>Timer, Op Amp, and Optoelectronic Circuits and Projects</em>. Radio Shack, 2000.
<br /> 
O’Sullivan, Dan, and Tom Igoe. <em>Physical Computing: Sensing and Controlling the Physical World with Computers</em>. Thomson Course Technology PTR, 2004.
<br /> 
Petzold, Charles. <em>Code: The Hidden Language of Computer Hardware and Software</em>. Microsoft Press, 2000.
<br /> 
Platt, Charles. <em>Make: Electronics</em>. Make, 2009.
<br /> 
Scherz, Paul. <em>Practical Electronics for Inventors</em>. McGraw-Hill, 2000.
<br />
<br />
<em>Artists, designers, institutions</em>
<br />
Dunne, Anthony, and Fiona Raby. <em>Design Noir</em>. Birkhäuser, 2001.
<br /> 
<a href="http://bureauit.org">Bureau of Inverse Technology</a>
<br />
<a href="http://www.kenfeingold.com">Feingold, Ken</a> 
<br />
Hawkinson, Tim. <em>Tim Hawkinson</em>. Harry N. Abrams, 2004.
<br /> 
<a href=" http://www.ideo.com">IDEO</a>. Design firm.
<br />
<a href="http://www.design-interactions.rca.ac.uk/">Design Interactions</a>. Royal College of Art. MFA program. 
<br />
<a href="http://itp.nyu.edu/itp">Interactive Telecommunication Program</a>. New York University. MFA program. 
<br />
<a href="http://www.mr-jones.org">Jones, Crispin</a>
<br />
<a href="http://www.vector-scan.com">Kuwakubo, Ryota</a>
<br /> 
<a href="http://www.maywadenki.com">Maywa Denki</a>
<br />
Paik, Nam June. <em>The Worlds of Nam June Paik</em>. Solomon R. Guggenheim Foundation, 2000.
<br /> 
<a href="http://tangible.media.mit.edu">Tangible Media Group</a>, MIT Media Lab.
<br />
<a href="http://www.bitforms.com/artist_vogel.html">Vogel, Peter</a>
</p>-->
</p>

</td>
       </tr>
 </table>