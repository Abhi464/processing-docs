<h1 style="line-height: 0.7em;">Sound</h1>
<h3 style="line-height: 0.7em;"><em>Text by R. Luke DuBois, code by Wilm Thoben</em></h3>

<table width="656">
	<tr>
	<td>

    <p class="license">
    	This tutorial is Extension 1 from the second edition of <em><a href="https://mitpress.mit.edu/books/processing-0">Processing: A Programming Handbook for Visual Designers and Artists</a></em>, published by MIT Press. Copyright 2014 MIT Press. This tutorial is for Processing version 2.0+. If you see any errors or have comments, please <a href="https://github.com/processing/processing-docs/issues?state=open">let us know</a>.
    </p>

	<p class="txt">
		The history of music is, in many ways, the history of technology. From developments in the writing and transcription of music (notation) to the design of spaces for the performance of music (acoustics) to the creation of musical instruments, composers and musicians have availed themselves of advances in human understanding to perfect and advance their professions. Unsurprisingly, therefore, we find that in the machine age these same people found themselves first in line to take advantage of the new techniques and possibilities offered by electricity, telecommunications, and, in the last century, digital computers to leverage all of these systems to create new and expressive forms of sonic art. Indeed, the development of phonography (the ability to reproduce sound mechanically) has, by itself, had such a transformative effect on aural culture that it seems inconceivable now to step back to an age where sound could emanate only from its original source.1 The ability to create, manipulate, and reproduce lossless sound by digital means is having, at the time of this writing, an equally revolutionary effect on how we listen. As a result, the artist today working with sound has not only a huge array of tools to work with, but also a medium exceptionally well suited to technological experimentation.
	</p>
 
	<h3>Music and sound programming in the arts</h3>
	
	<p class="txt">
		Thomas Edison’s 1857 invention of the phonograph and Nikola Tesla’s wireless radio demonstration of 1893 paved the way for what was to be a century of innovation in the electromechanical transmission and reproduction of sound. Emile Berliner’s gramophone record (1887) and the advent of AM radio broadcasting under Guglielmo Marconi (1922) democratized and popularized the consumption of music, initiating a process by which popular music quickly transformed from an art of minstrelsy into a commodified industry worth tens of billions of dollars worldwide.2 New electronic musical instruments, from the large and impractical telharmonium to the simple and elegant theremin multiplied in tandem with recording and broadcast technologies and prefigured the synthesizers, sequencers, and samplers of today. Many composers of the time were, not unreasonably, entranced by the potential of these new mediums of transcription, transmission, and performance. Luigi Russolo, the futurist composer, wrote in his 1913 manifesto The Art of Noises of a futurist orchestra harnessing the power of mechanical noisemaking (and phonographic reproduction) to “liberate” sound from the tyranny of the merely musical. John Cage, in his 1937 monograph Credo: The Future of Music, wrote this elliptical doctrine:</p>
    	
    	<blockquote>
			The use of noise to make music will continue and increase until we reach a music produced through the aid of electrical instruments which will make available for musical purposes any and all sounds that can be heard. Photoelectric, film, and mechanical mediums for the synthetic production of music will be explored. Whereas, in the past, the point of disagreement has been between dissonance and consonance, it will be, in the immediate future, between noise and so-called musical sounds.3
		</blockquote>
		
	<p class="txt">
		The invention and wide adoption of magnetic tape as a medium for the recording of audio signals provided a breakthrough for composers waiting to compose purely with sound. In the early postwar period, the first electronic music studios flourished at radio stations in Paris (ORTF) and Cologne (WDR). The composers at the Paris studio, most notably Pierre Henry and Pierre Schaeffer, developed the early compositional technique of musique concrète, working directly with recordings of sound on phonographs and magnetic tape to construct compositions through a process akin to what we would now recognize as sampling. Schaeffer’s Étude aux chemins de fer (1948) and Henry and Schaeffer’s Symphonie pour un homme seul are classics of the genre. Meanwhile, in Cologne, composers such as Herbert Eimart and Karlheinz Stockhausen were investigating the use of electromechanical oscillators to produce pure sound waves that could be mixed and sequenced with a high degree of precision. This classic elektronische music was closely tied to the serial techniques of the contemporary modernist avant-garde, who were particularly well suited aesthetically to become crucial advocates for the formal quantification and automation offered by electronic and, later, computer music.4 The Columbia-Princeton Electronic Music Center, founded by Vladimir Ussachevsky, Otto Luening, Milton Babbitt, and Roger Sessions in New York in 1957, staked its reputation on the massive RCA Mark II Sound Synthesizer, a room-sized machine capable of producing and sequencing electronically generated tones with an unprecedented degree of precision and control. In the realm of popular music, pioneering steps were taken in the field of recording engineering, such as the invention of multitrack tape recording by the guitarist Les Paul in 1954. This technology, enabling a single performer to “overdub” her/himself onto multiple individual “tracks” that could later be mixed into a composite, filled a crucial gap in the technology of recording and would empower the incredible boom in recording-studio experimentation that permanently cemented the commercial viability of the studio recording in popular music.
    </p>

    <p class="txt">
		Composers adopted digital computers slowly as a creative tool because of their initial lack of real-time responsiveness and intuitive interface. Although the first documented use of the computer to make music occurred in 1951 on the CSIRAC machine in Sydney, Australia, the genesis of most foundational technology in computer music as we know it today came when Max Mathews, a researcher at Bell Labs in the United States, developed a piece of software for the IBM 704 mainframe called MUSIC. In 1957, the MUSIC program rendered a 17-second composition by Newmann Guttmann called “In the Silver Scale”. Originally tasked with the development of human-comprehensible synthesized speech, Mathews developed a system for encoding and decoding sound waves digitally, as well as a system for designing and implementing digital audio processes computationally. His assumptions about these representational schemes are still largely in use and will be described later in this text. The advent of faster machines, computer music programming languages, and digital systems capable of real-time interactivity brought about a rapid transition from analog to computer technology for the creation and manipulation of sound, a process that by the 1990s was largely comprehensive.5
	</p>

<p>
<h3>Electricity</h3>
Electricity is something we use daily, but it is difficult to understand. Its effect is experienced in many ways, from observing a light turn on to noticing the battery charge deplete on a laptop computer. 
<br />
<br />
	Electrical current is a stream of moving electrons. They flow from one point to another through a <em>conductor</em>. Some materials are better conductors than others. Sticking a fork in a light socket is dangerous because metal is a good conductor and so is your body. The best conductors are copper, silver, and gold. A resistor is the opposite of a conductor. Resistance is the capability of a material to resist the flow of electrons. A substance with a very high resistance is an <em>insulator</em>. Plastic and rubber are excellent insulators, and for this reason they are used as the protective covering around wires. Electrical energy, the difference of electrical potential between two points, is called <em>voltage</em>. The amount of electrical charge per second that flows through a point is the <em>current</em>. Resistance is measured in units called ohms, voltage is measured in volts, and current is measured in amperes (amps). The relation between the three is easiest to understand through an analogy of water flowing through a hose. As explained by the educators Dan O’Sullivan and Tom Igoe:
<br />
<br />
	The flow of water through a hose is like the flow of electricity through a circuit. Turning the faucet increases the amount of water coming through the hose, or increases the current (amps). The diameter of the hose offers resistance to the current, determining how much water can flow. The speed of the water is equivalent to voltage. When you put your thumb over the end of the hose, you reduce the diameter of the pathway of the water. In other words, the resistance goes up. The current (that is, how much water is flowing) doesn’t change, however, so the speed of the water, or voltage, has to go up so that all the water can escape . . . 1
<br />
<br />
	Electrical current flows in two ways: direct current (DC) and alternating current (AC). A DC signal always flows in the same direction and an AC signal reverses the direction of flow at regular intervals. Batteries and solar cells produce DC signals, and the power that comes from wall sockets is an AC signal:
<br />
<br /> 
<img src="imgs/39-1(ACDC).svg" style= "width: 687px; height: 100px">
<br />
	Depending on your country, the AC power source coming into your home is between 100 and 240 volts. Most home appliances can directly use AC current to operate, but some use a power supply to convert the higher-potential AC current into DC current at smaller voltages. A common example of this type of power supply are the black plastic boxes (a k a power bricks, power adapters, wall warts) that are used to power laptops or mobile phones from the home AC power source. Most desktop computers have an internal power supply to convert the AC source to the 12-volt and 5-volt DC supply necessary to run the internal electronics. Low voltages are generally safer than high voltages, but it’s the amount of current (amps) that makes electricity dangerous.
</p>
<br />
<br />

<p>
<h3>Components</h3>
	Electronic components are used to affect the flow of electricity and to convert electrical energy into other forms such as light, heat, and mechanical energy. There are many different components, each with a specific use, but here we introduce four of the most basic types: resistor, capacitor, diode, and transistor. 
<br />
<br />
<em>Resistor</em>
<br />
	A resistor limits (provides resistance to) the flow of electricity. Resistors are measured in units called ohms. The value 10 ohms is less resistance than 10,000 (10K) ohms. The value of each resistor is marked on the component with a series of colored bands. A variable resistor that changes its resistance when a slider, knob, or dial attached to it is turned is called a potentiometer or trimmer. Variable resistors are designed to change in response to different environmental phenomena. For example, one that changes in response to light is called a photoresistor or photocell, and one that changes in response to heat is called a thermistor. Resistors can be used to limit current, reduce voltage, and perform many other essential tasks. 
<br />
<br />
<img src="imgs/fg39-2.jpg">
<br />
<em>Capacitor</em>
<br />
	A capacitor stores electrons i.e. electrical charge; it gains charge when current flows in, and it releases charge (discharges) when the current flows out. This can smooth out the dips and spikes in a current signal. Capacitors are combined with resistors to create filters, integrators, differentiators, and oscillators. A simple capacitor is two parallel sheets of conductive materials, separated by an insulator. Capacitors are measured in units called farads. A farad is a large measurement, so most capacitors you will use will be measured in microfarads (µF), picofarads (pF), or nanofarads (nF). 
<br />
<br />
<img src="imgs/fg39-4.jpg">
<br />
<br />
<em>Diode</em>
<br />
	Current flows only in one direction through a diode. One side is called the cathode (marked on the device with a line) and the other is the anode. Current flows when the anode is more positive than the cathode. Diodes are commonly used to block or invert the negative part of an AC signal. A light-emitting diode (LED) is used to produce light. The longer wire coming out of the LED is the anode and the other is the cathode. LEDs come in many sizes, forms, colors, and brightness levels. 
<br />
<br />
<img src="imgs/fg39-5.jpg">
<br />
<br />
<em>Transistor</em>
<br /> 
	A transistor can be used as an electrical switch or an amplifier. A bipolar transistor has three leads (wires) called the base, collector, and emitter. Depending on the type of transistor, applying current to the base either allows current to flow or stops it from flowing through the device from the collector to the emitter. Transistors make it possible for the low current from a microcontroller to control the much higher currents necessary for motors and other power-hungry devices, and thus to turn them on and off.
<br />
<br />
<img src="imgs/fg39-6.jpg">
</p>
<p>
	<h3>Circuits</h3>
	An electrical circuit is a configuration of components, typically designed to produce a desired behavior such as decreasing the current, filtering a signal, or turning on an LED. The following simple circuit can be used to turn a light on and off:
<br />
<br />
	<img src="imgs/fg39-7.jpg">
	This simple electric circuit is a closed loop with an energy source (battery), a load (lightbulb) that offers a resistance to the flow of electrons and transforms the electric energy into another form of energy (light), wires that carry the electricity, and a switch to connect and disconnect the wires. The electrons move from one end of the battery, through the load, and to the other end.
<br />
<br />
	Circuits are usually represented with diagrams. A circuit diagram uses standardized symbols to represent specific electrical components. It is easier to read the connections on a diagram than on photographs of the components. A diagram of the simple circuit above could look like this:
<br />
<br />
	<img src="imgs/fg39-8.svg" style= "width: 687px; height: 120px">
<br />
	Circuits are often prototyped on a "breadboard,” a rectangular piece of plastic with holes for inserting wires. A breadboard makes it easy to quickly make variations on a circuit without soldering (fusing components together with a soft metal). Conductive strips underneath the surface connect the long horizontal rows at the top and bottom of the board and the short vertical rows within the middle: 
<br />
<br />
	<img src="imgs/fg39-9.svg" style= "width: 687px; height: 120px">
<br />
	Circuits are tested with a multimeter, an instrument to measure volts, current, resistance, and other electrical properties. A multimeter allows the electrical properties of the circuit to be read as numbers and is necessary for debugging. Analog multimeters have a small needle that moves from left to right, and digital multimeters have a screen that displays numbers. Most multimeters have two metal prongs to probe the circuit and a central dial to select between different modes. 
<br />
<br />
	Commonly used circuits are often condensed into small packages. These integrated circuits (ICs, or chips) contain dense arrangements of miniaturized components. They are typically small, black plastic rectangles with little metal pins sticking out of the sides. Like objects in software, these devices are used as building blocks for creating more complicated projects. ICs are produced to generate signals, amplify signals, control motors, and perform hundreds of other functions. They fit neatly into a breadboard by straddling the gap in the middle.
</p>
<br />
<br />
<p>
	<h3>Microcontrollers and I/O boards</h3>
	Microcontrollers are small and simple computers. They are the tiny computer brains that automate many aspects of contemporary life, through their activities inside devices ranging from alarm clocks to airplanes. A microcontroller has a processor, memory, and input/output interfaces enclosed within a single programmable unit. They range in size from about 1 × 1 cm to 5 × 2 cm. Like desktop computers, they come in many different configurations. Some have the same speed and memory as a personal computer from twenty years ago, but they are much less powerful than current machines, as this comparison tables shows:

<table border="0" style="width:500px">
<tr>
  <td><em>Model</em></td>
  <td><em>Speed</em></td>		
  <td><em>Memory</em></td>
  <td><em>Cost</em></td></tr>
  <tr><td><pre class ="table">Apple Macintosh (1984)</pre></td>
  <td><pre class="table">8MHz</pre></td>		
  <td><pre class="table">128 Kb</pre></td>
  <td><pre class="table">$2500</pre></td></tr>
  <tr><td><pre class="table">Atmel ATmega128-8AC Microcontroller</pre></td>
  <td><pre class="table">8MHz</pre></td>		
  <td><pre class="table">128 Kb</pre></td>
  <td><pre class="table">$15</pre></td></tr>
  <tr><td><pre class="table">Apple Mac Mini (2006)</pre></td>
  <td><pre class="table">1500 MHz</pre></td>		
  <td><pre class="table">512,000 Kb</pre></td>
  <td><pre class="table">$600</pre></td>
</tr>
</table>

<br />
	Small metal pins poking out from a microcontroller’s edges allow access to the circuits inside. Each pin has its own role. Some are used to supply power, some are for communication, some are inputs, and others can be set to either input or output. The relative voltage at each input pin can be read through software, and the voltage can be set at each output pin. Some pins are reserved for communication. They allow a microcontroller to communicate with computers and other microcontrollers through established communication protocols such as RS-232 serial.
<br /> 
<br /> 
	Microcontrollers can be used to build projects directly, but they are often packaged with other components onto a printed circuit board (PCB) to make them easier to use for beginners and for rapid prototyping. We call these boards I/O boards (input/output boards) because they are used to get data in and out of a microcontroller. They are also called microcontroller modules. We’ve created three informal groups—bare microcontrollers, programmable I/O boards, and tethered I/O boards—to discuss different ways to utilize microcontrollers in a project.
<br />
<br />
<em>Bare microcontrollers </em>
<br />
	Working directly with a bare microcontroller is the most flexible but most difficult way to work. It also has the potential to be the least expensive way of building with electronics, but this economy can be offset by initial development costs and the extra time spent learning how to use it. Microchip PIC and Atmel AVR are two popular families of microcontrollers. Each has variations ranging from simple to elaborate that are appropriate for different types of projects. The memory, speed, and other features effect the cost, the number of pins, and the size of the package. Both families feature chips with between eight and 100 pins with prices ranging from under $1 to $20. PIC microcontrollers have been on the market for a longer time, and more example code, projects, and books are available for beginners. The AVR chips have a more modern architecture and a wider range of open-source programming tools. Microcontrollers are usually programmed in the C language or their assembly language, but it’s also possible to program them in other languages such as BASIC. If you are new to electronics and programming, we don’t recommend starting by working directly with PIC or AVR chips. In our experience, beginners have had more success with the options introduced below.

<br />
<br />
<em>Programmable I/O boards</em>
<br />
	A programmable I/O board is a microcontroller situated on a PCB with other components to make it easier to program, attach/detach components, and turn on and off. These boards typically have components to regulate power to protect the microcontroller and a USB or RS-232 serial port connector to make it easy to attach cables for communication. The small pins on the microcontroller are wired to larger pins called headers, which make it easy to insert and remove sensors and motors. Small wires embedded within the PCB connect pins to a corresponding header. Small reset switches make it easy to restart the power without having to physically detach the power supply or battery.
<br /> 
<br /> 
	Within the context of this book, the most relevant I/O boards are Wiring and Arduino. Both were created as tools for designers and artists to build prototypes and to learn about electronics. Both boards use the Wiring language to program their microcontrollers and use a development environment built from the Processing environment. In comparison to the Processing language, the Wiring language provides a similar level of control and ease of use within its domain. They share common language elements when possible, but Wiring has some functions specific to programming microcontrollers and omits the graphics programming functions within Processing. Like Processing programs, Wiring programs are translated into another language before they are run. When a program written with the Wiring language is compiled, it’s first translated into the C/C++ language and then compiled using a C/C++ compiler.
<br />
<br />
<img src="imgs/fg39-10.jpg">
<br />
<br />

<em>Tethered I/O boards</em>
<br />
	A tethered I/O board is used to get sensor data into a computer and to control physical devices (motors, lights, etc.) without the need to program the board. A computer already has many input and output devices such as a monitor, mouse, and keyboard; and tethered I/O boards provide a way to communicate between more exotic input devices such as light sensors and video cameras, and output devices such as servomotors and lights. These boards are designed to be easy to use. They often do not require knowledge of electronics because sensors and motors can be plugged directly into the board and do not need to interface with other components. Messages are sent and received from the boards through software such as Processing, Max, Flash, and many programming languages. This ease of use often comes at a high price.
</p>
<br />
<br />
<p>
<h3>Sensors and communication</h3>
	Physical phenomena are measured by electronic devices called sensors. Different sensors have been invented to acquire data related to touch, force, proximity, light, orientation, sound, temperature, and much more. Sensors can be classified into groups according to the type of signals they produce (analog or digital) and the type of phenomena they measure. Analog signals are continuous, but digital signals are constrained to a range of values (e.g., 0 to 255): 
<br />
<br />
<img src="imgs/fg39-11.svg" style= "width: 687px; height: 100px" />
<br />
	Most basic analog sensors utilize resistance. Changes in a physical phenomenon modify the resistance of the sensor, therefore varying the voltage output through the sensor. An analog-to-digital converter can continuously measure this changing voltage and convert it to a number that can be used by software. Sensors that produce digital signals send data as binary values to an attached device or computer. These sensors use a voltage (typically between 3.5 and 5 volts) as ON (binary digit 1 or TRUE) and no voltage as a OFF (binary digit 0 or FALSE). More complex sensors include their own microcontrollers to convert the data to digital signals and to use established communication protocols for transmitting these signals to another computer.
<br />
<br />
<em>Touch and force</em>
<br />
	Sensing of touch and force is achieved with switches, capacitive sensors, bend sensors, and force-sensitive resistors. A switch is the simplest way to detect touch. A switch is a mechanism that stops or allows the flow of electricity depending on its state, either open (OFF) or closed (ON). Some switches have many possible positions, but most can only be ON or OFF. Touch can also be detected with capacitive sensors. These sensors can be adjusted to detect the touch and proximity (within a few millimeters) of a finger to an object. The sensor can be positioned underneath a nonconductive surface like glass, cardboard, or fabric. This type of sensor is often used for the buttons in an elevator. A bend (flex) sensor is a thin strip of plastic that changes its resistance as it is bent. A force-sensitive resistor (FSR or force sensor) changes its resistance depending on the magnitude of force applied to its surface. FSRs are designed for small amounts of force like the pressure from a finger, and they are available in different shapes including long strips and circular pads.
<br />
<br />
<em>Presence and distance</em>
<br />
	There are a wide variety of sensors to measure distance and determine whether a person is present. The simplest way to determine presence is a switch. A switch attached to a door, for example, can be used to determine whether it is open or closed. A change in the state (open or closed) means someone or something is there. Switches come in many different shapes and sizes, but the category of small ones called <em>microswitches</em> are most useful for this purpose. The infrared (IR) motion detectors used in security systems are another simple way to see if something is moving in the environment. They can’t measure distance or the degree of motion, but they have a wide range, and some types can be purchased at hardware stores. IR distance sensors are used to calculate the distance between the sensor and an object. The distance is converted into a voltage between 0 and 5 volts that can be read by a microcontroller. Ultrasonic sensors are used for measuring up to 10 meters. This type of device sends a sound pulse and calculates how much time it takes to receive the echo. 
<br />
<br />
<em>Light</em>
<br />
	Sensors for detecting light include photoresistors, phototransistors, and photodiodes. A photoresistor (also called a photocell) is a component that changes its resistance with varying levels of light. It is among the easiest sensors to use. A phototransitor is more sensitive to changes in light and is also easy to use. Photodiodes are also very sensitive and can respond faster to changing light levels, but they are more complex to interface with a microcontroller. Photodiodes are used in the remote control receivers of televisions and stereos. 

<br />
<br />
<em>Position and orientation</em>
<br />
	A potentiometer is a variable resistor that works by twisting a rotary knob or by moving a slider up and down. The potentiometer’s resistance changes with the rotation or up/down movement, and this can affect the voltage level within a circuit. Most rotary potentiometers have a limited range of rotation, but some are able to turn continuously. A tilt sensor is used to crudely measure orientation (up or down). It is a switch with two or more wires and a small metal ball or mercury in a box that touches wires in order to complete a circuit when it is in a certain orientation. An accelerometer measures the change in movement (acceleration) of an object that it is mounted to. Tiny structures inside the device bend as a result of momentum, and the amount of bending is measured. Accelerometers are used in cameras to control image stabilization and in automobiles to detect rapid deceleration and release airbags. A digital compass calculates orientation in relation to the earth’s magnetic field. The less expensive sensors of this type have a lower accuracy, and they may not work well when situated near objects that emit electromagnetic fields (e.g., motors). 
<br />
<br />
	<em>Sound</em>
<br />
	A microphone is the simplest and most common device used to detect and measure sound. Sudden changes in volume are the easiest sound elements to read, but processing the sound wave with software (or special hardware) makes it possible to detect specific frequencies or rhythms. A microphone usually requires extra components to amplify the signal before it can be read by a microcontroller. Piezo electric film sensors, commonly used in speakers and microphones, can also be used to detect sound. Sampling a sound wave with a microcontroller can dramatically reduce the quality of the audio signal. For some applications, it’s better to sample and analyze sound through a desktop computer and to communicate the desired analysis information to an attached microcontroller.
<br />
<br />
<em>Temperature</em>
<br />
	A thermistor is a device that changes its resistance with temperature. These sensors are easy to interface, but they respond slowly to changes. To quantitatively measure temperature, a more sophisticated device is needed. Flame sensors are tuned to detect open flames such as lighters and candles.
<br />
<br />
	Analog voltage signals from sensors can’t be directly interpreted by a computer, so they must be converted to a digital value. Some microcontrollers provide analog-to-digital converters (ADC or A/D) that measure variations in voltage at an input pin and convert it to a digital value. The range of values depends on the resolution of the ADC; common resolutions are 8 and 10 bits. At 8-bit resolution, an ADC can represent 28 (256) different values, where 0 volts corresponds to the value 0 and 5 volts corresponds to 255. A 10-bit ADC provides 1024 different values, where 5 volts corresponds to the value 1023. 
<br />
<br />
	Data is sent and received between microcontrollers and computers according to established data protocols such as RS-232 serial, USB, MIDI, TPC/IP, Bluetooth, and other proprietary formats like I2C or SPI. Most electronics prototyping kits and microcontrollers include an RS-232 serial port, and this is therefore a convenient way to communicate. This standard has been around for a long time (it was developed in the late 1960s) and it defines signal levels, timing, physical plugs, and information exchange protocols. The physical RS-232 serial port has largely been replaced in computers by the faster and more flexible (but more complex) universal serial bus (USB), but the protocol is still widely used when combining the USB port with software emulation.
<br />
<br />
	Because a device can have several serial ports, a user must specify which serial port to use for data transmission. On most Windows computers, serial port names are <code>COMx</code>, where <code>x</code> can be 1, 2, 3, etc. On UNIX-based systems (Mac OS X and Linux), serial devices are accessed through files in the <em>/dev/</em> directory. After the serial port is selected, the user must specify the settings for the port. Communication speed will vary with devices, but typical values are 9600, 19,200, and 115,200 bits per second. Once the ports are open for communication on both devices, it is possible to send and receive data.
<br />
<br />
	The following examples connect sensors and actuators to a Wiring or Arduino board and communicate the data between the I/O board and a Processing application. When the Wiring and Arduino boards are plugged into a computer’s USB port, it appears on the computer as a serial port, making it possible to send/receive data on it. The Wiring board has two serial ports called <em>Serial</em> and <em>Serial1</em>; the Arduino board has one called Serial. Serial is directly available on the USB connector located on the board surface. <em>Serial1</em> is available through the Wiring board digital pin numbers 2(Rx) and 3(Tx) for the user’s applications.
<br />
<br /> 
<em>Example 1:  Switch</em>
<br /> 
	This example sends the status of a switch (ON or OFF) connected to the Wiring or Arduino board to a Processing application running on a computer. Software runs on the board to read the status of a switch connected on digital pin 4. This value 1 is sent to the serial port continuously while the switch is pressed and 0 is sent continuously when the switch is not pressed. The Processing application continuously receives data from the board and assigns the color of a rectangle on the screen depending on the value of the data. When the switch is pressed the rectangle’s color changes from black to light gray.
<br />
<br /> 
<em>Example 2:  Light sensor</em>
<br /> 
	This example brings data from a light sensor (photoresistor) connected to the Wiring or Arduino board’s analog input pin 0 into a Processing application running on a computer. Software runs on the board to send the value received from the light sensor to the serial port. Because the light sensor is plugged into an analog input pin, the analog voltage coming into the board is converted into a digital number before it is sent over the serial port. The Processing application changes the color of a rectangle on-screen according to the value sent from the board. The rectangle exhibits grays from black to white according to the amount of light received by the sensor. Cover and uncover the sensor with your hand to see a large change.
</p>
<br />
<br /> 
<p>
	<h3>Controlling physical media</h3>
	Actuators are devices that act on the physical world. Different types of actuators can create light, motion, heat, and magnetic fields. The digital output pin on a microcontroller can be set to a voltage of 0 or 5 volts. This value can be used to turn a light or motor on or off, but finer control over brightness and speed requires an analog output. By using a digital to analog converter (DAC), a discretized signal can be directly generated as illustrated in the previous figure. If desired, some smoothing can be added to obtain the desired analog signal. When a DAC is not available or not justified in terms of cost or conversion speed, another approach is to use a technique called pulse-width modulation (PWM). This is turning a digital output ON and OFF very quickly to simulate values between 0 and 5 volts. If the output is 0 volts for 90% of the time and 5 volts for 10%, this is called a 10% duty cycle. Following smoothing, it emulates an analog voltage of 0.5 volts. An 80% duty cycle with smoothing emulates a 4-volt signal:
<br />
<br />
	<img src="imgs/fg39-12.svg" style= "width: 687px; height: 100px">
<br /> 
	The PWM technique can be used to dim a light, run a motor at a slow speed, and control the frequency of a tone through a speaker. In some applications, any necessary smoothing is obtained for free e.g. the inertia in a motor can average out the PWM duty cycle and result in smooth motion.
<br /> 
<br /> 
	<em>Light</em>
<br />
	Sending current through a light-emitting diode (LED) is the simplest way to get a microcontroller to control light. An LED is a semiconductor device that emits monochromatic light when a current is applied to it. The color (ranging from ultraviolet to infrared) depends on the semiconductor material used in its construction. LEDs have a wide range of applications from simple blinking indicators and displays to street lamps. They have a long life and are very efficient. Some types of LEDs and high-power LEDs require special power arrangements and interfacing circuits before they can be used with microcontrollers. Incandescent, fluorescent, and electroluminescent light sources always require special interfacing circuits before they can be controlled.
<br /> 
<br /> 
	<em>Motion</em>
<br />
	Motors are used to create rotational and linear movement. The rated voltage, the current drawn by the motor, internal resistance, speed, and torque (force) are factors that determine the power and efficiency of the motor. Direct current (DC) motors turn continuously at very high speeds and can switch between a clockwise and counterclockwise direction. They are usually interfaced with a gearbox to reduce the speed and increase the power. Servomotors are modified DC motors that can be set to any position within a 180-degree range. These motors have an internal feedback system to ensure they remain at their position. Stepper motors move in discrete steps in both directions. The size of the steps depends on the resolution of the motor. Solenoids move linearly (forward or back instead of in circles). A solenoid is a coil of wire with a shaft in the center. When current is applied to the coil, it creates a magnetic field that pulls or pushes the shaft, depending on the type. Muscle wire (shape memory alloy or nitinol) is a nickel-titanium alloy that contracts when power is applied. It is difficult to work with and is slower than motors, but requires less current and is smaller. DC and stepper motors need special interfacing circuits because they require more current than a microcontroller can supply through its output pins. H-bridge chips simplify this interface. 
<br /> 
<br /> 
	<em>Switches</em>
<br />
	Relays and transistors are used to turn on and off electric current. A relay is an electromechanical switch. It has a coil of wire that generates a magnetic field when an electrical current is passed through. The magnetic field pulls together the two metal contacts of the relay’s switch. Solid-state relays without moving parts are faster than electromechanical relays. Using relays makes it possible to turn ON and OFF devices that can’t be connected directly to a microcontroller. These devices include home appliances, 120-volt light bulbs, and all other devices that require more power than the microcontroller can provide. Transistors can also behave like switches. Because they operate electronically and not mechanically, they are much faster than relays.
<br /> 
<br /> 
	<em>Sound</em>
<br />
	Running a signal from a digital out or PWM pin to a small speaker is the easiest way to produce a crude, buzzing noise. For more sophisticated sounds, attach these pins to tone-generator circuits created with a 555 timer IC, capacitors, and resistors. Some chips are designed specifically to record and play back sound. Others are sound synthesizers that can synthesize speech by configuring stored phonemes. 
<br /> 
<br /> 
	<em>Temperature</em>
<br />
	Temperature can be controlled by a Peltier junction, a device that works as a heat pump. It transforms electricity into heat and cold at the same time by extracting thermal energy from one side (cooling) into the other side (heating). It can also work in reverse, applying heat or cold to the proper surface to produce an electrical current. Because this device consumes more current than a microcontroller can handle in an output pin, it must be interfaced using transistors, relays, or digital switches like the ones described above.
<br /> 
<br /> 
	The following examples demonstrate how to control lights and motors attached to an I/O board through a Processing program:
<br /> 
<br /> 
	<em>Example 3:  Turning a light on and off</em>
<br />
	This example sends data from a Processing program running on a computer to a Wiring or Arduino board to turn a light ON or OFF. The program continually writes an <em>H</em> to the serial port if the cursor is inside the rectangle and writes a <em>L</em> if it’s not. Software running on the board receives the data and checks for the value. If the value is <em>H</em>, it turns on a light connected to the digital I/O pin number 4, and if the value is <em>L</em>, it turns off the light. The light always reflects the status of the rectangle on the computer’s screen.
<br /> 
<br /> 
	<em>Example 4:  Controlling a servomotor</em>
<br />
	This example controls the position of a servomotor through an interface within a Processing program. When the mouse is dragged through the interface, it writes the position data to the serial port. Software running on a Wiring or Arduino board receives data from the serial port and sets the position of a servomotor connected to the digital I/O pin number 4.
<br />
<br /> 
	<em>Example 5:  Turning a DC motor on and off</em>
<br />
	This example controls a DC motor from a Processing program. The program displays an interface that responds to a mouse click. When the mouse is clicked within the interface, the program writes data to the serial port. Software running on the board receives data from the serial port and turns the DC motor connected to the PWM pin ON and OFF. The DC motor is connected to the board through an L293D chip to protect the microcontroller from current spikes caused when the motor turns on.
</p>
<br />
<br /> 
<p>
	<h3>Conclusion</h3>
	Electronic components and microcontrollers are becoming more common in designed objects and interactive artworks. Although the programming and electronics skills required for many projects call for an advanced understanding of circuits, a number of widely used and highly effective techniques can be implemented and quickly prototyped by novices. The goal of this text is to introduce electronics and to provide enough information to encourage future exploration. As you pursue electronics further, we recommend that you read <em>CODE</em> by Charles Petzold to gain a basic understanding of how electronics and computers work, and we recommend that you read <em>Physical Computing</em> by Dan O’Sullivan and Tom Igoe for a pragmatic introduction to working with electronics. <em>Practical Electronics for Inventors</em> by Paul Scherz is an indispensable resource, and the <em>Engineer’s Mini Notebook</em> series by Forrest M. Mims III is an excellent source for circuit designs. The Web is a deep resource for learning about electronics, and there are many excellent pages listed below in Resources. The best way to learn is by making projects. Build many simple projects and work through the examples in <em>Physical Computing</em> to gain familiarity with the different components.
<br />
<br />
Notes
<br />
1. Dan O’Sullivan and Tom Igoe, <em>Physical Computing: Sensing and Controlling the Physical World with Computers</em> (Thomson Course Technology PTR, 2004), p. TC
</p>
<br />
<br />
<p>
<h3>Code</h3>
<p>
To run these examples, unlike the other examples in this book, you will need additional equipment. They require either a Wiring (wiring.org.co) or Arduino (www.arduino.cc) board and the following:
<br /> 
<br /> 
    <ul>
<li>USB cable (used to send data between board and computer)</li>
<li>9–15V 1000mA power supply or 9V battery</li>
<li>22-gauge solid core wire (get different colors)</li>
<li>Breadboard</li>
<li>Switch</li>
<li>Resistors  (10K ohm for the switch circuits, 330 ohm for the LEDs, 1K ohm for the photoresistor)</li>
<li>LEDs</li>
<li>Servo motor (Futaba or Hi-Tech)</li>
<li>DC motor (a generic DC motor like the ones in toy cars)</li>
<li>L293D or SN754410 H-Bridge Integrated Circuit</li>
<li>Wire cutters</li>
<li>Wire strippers</li>
<li>Needlenose pliers </li>
    </ul> 
<br /> 
This equipment can be purchased from an electronics store such as Radio Shack or from an online vendor.
<br />
<br />
	Each example presents two programs: code for the I/O board and code for Processing. Diagrams and breadboard illustrations for the examples are presented side by side in this tutorial to reinforce the connections between the two representations. Learning to translate a circuit diagram into a physical circuit is one of the most difficult challenges when starting to work with electronics. 
<br />
<br />
	The Wiring or Arduino software environment is necessary to program each board. These environments are built on top of the Processing environment, but they have special features for uploading code to the board and monitoring serial communication. Both can be downloaded at no cost from their respective websites and both are available for Linux, Macintosh, and Windows. 
<br />
<br />
	The examples that follow assume the I/O board is connected to your computer and serial communication is working. Before working with these examples, get one of the simple Serial library examples included with Processing to work. For the most up-to-date information and troubleshooting tips, read the Serial reference on the Processing website: www.processing.org/reference/libraries. The Wiring and Arduino websites have additional information.
<br />
<br /> 
<hr />
<br /> 
<br />
<em>Example 1A:  Switch (Wiring/Arduino)</em>
<br /> 
<br /> 
<img src="imgs/fg39-13.svg" style= "width: 687px; height: 220px">
<br /> 
<pre>
// Code for sensing a switch status and writing the value to the serial port

int switchPin = 4;  		       // Switch connected to pin 4 
 
void setup() { 
  pinMode(switchPin, INPUT);  	       // Set pin 0 as an input 
  Serial.begin(9600);         	       // Start serial communication at 9600 bps 
} 
 
void loop() { 
  if (digitalRead(switchPin) == HIGH) {  // If switch is ON, 
    Serial.print(1, BYTE);               // send 1 to Processing
  } else {                               // If the switch is not ON,
    Serial.print(0, BYTE);               // send 0 to Processing 
  } 
  delay(100);                            // Wait 100 milliseconds 
} 
</pre>
<br /> 
<br />
<em>Example 1B:  Switch (Processing)</em>
<pre>
// Read data from the serial port and change the color of a rectangle 
// when a switch connected to the board is pressed and released
 
import processing.serial.*; 
 
Serial port;                             // Create object from Serial class 
int val;                                 // Data received from the serial port 
 
void setup() { 
  size(200, 200); 
  frameRate(10); 
  // Open the port that the board is connected to and use the same speed (9600 bps) 
  port = new Serial(this, 9600); 
} 

void draw() { 
  if (0 &lt; port.available()) {            // If data is available,
    val = port.read();                   // read it and store it in val
  } 
  background(255);                       // Set background to white
  if (val == 0)  {                       // If the serial value is 0,
    fill(0);                             // set fill to black
  } else {                               // If the serial value is not 0,
    fill(204);                           // set fill to light gray
  } 
  rect(50, 50, 100, 100);
} 
</pre>
<br />
<hr />
<br />
<em>Example 2A:  Light sensor (Wiring/Arduino)</em>
<br />
<br /> 
<img src="imgs/fg39-14.svg" style= "width: 687px; height: 220px">
<br /> 
<pre>
// Code to read an analog value and write it to the serial port

int val; 
int inputPin = 0;                // Set the input to analog in pin 0
 
void setup() { 
  Serial.begin(9600);            // Start serial communication at 9600 bps 
} 
 
void loop() { 
  val = analogRead(inputPin)/4;  // Read analog input pin, put in range 0 to 255
  Serial.print(val, BYTE);       // Send the value
  delay(100);                    // Wait 100ms for next reading 
}
</pre>
<br /> 
<br /> 
<em>Example 2B:  Light sensor (Processing)</em>
<pre>
// Read data from the serial port and assign it to a variable. Set the fill a 
// rectangle on the screen using the value read from a light sensor connected 
// to the Wiring or Arduino board 
 
import processing.serial.*; 
 
Serial port;  			       // Create object from Serial class
int val;      			       // Data received from the serial port 
 
void setup() { 
  size(200, 200); 
  noStroke(); 
  frameRate(10);                // Run 10 frames per second
  // Open the port that the board is connected to and use the same speed (9600 bps) 
  port = new Serial(this, 9600); 
} 

void draw() { 
  if (0 &lt; port.available()) {    // If data is available to read,
    val = port.read();           // read it and store it in val
  } 
  background(204);               // Clear background
  fill(val);                     // Set fill color with the value read
  rect(50, 50, 100, 100);        // Draw square
} 
</pre>
<br />
<hr />
<br />
<em>Example 3A: Turning a light on and off</em>
<br /> 
<br /> 
<img src="imgs/fg39-15.svg" style= "width: 687px; height: 220px">
<br /> 
<pre>
// Read data from the serial and turn ON or OFF a light depending on the value
 
char val;                          // Data received from the serial port 
int ledPin = 4;                    // Set the pin to digital I/O 4

void setup() { 
  pinMode(ledPin, OUTPUT);         // Set pin as OUTPUT 
  Serial.begin(9600);              // Start serial communication at 9600 bps 
} 
 
void loop() { 
  if (Serial.available()) {        // If data is available to read, 
    val = Serial.read();           // read it and store it in val 
  } 
  if (val == 'H') {                // If H was received
    digitalWrite(ledPin, HIGH);    // turn the LED on 
  } else { 
    digitalWrite(ledPin, LOW);     // Otherwise turn it OFF
  } 
  delay(100);                      // Wait 100 milliseconds for next reading 
} 
</pre>
<br /> 
<br /> 
<em>Example 3B: Turning a light on and off (Processing)</em>
<pre>
// Check if the mouse is over a rectangle and write the status to the serial port

import processing.serial.*; 
 
Serial port;                       // Create object from Serial class
 
void setup() { 
  size(200, 200); 
  noStroke(); 
  frameRate(10); 
  // Open the port that the board is connected to and use the same speed (9600 bps)
  port = new Serial(this, 9600); 
} 
 
void draw() { 
  background(255); 
  if (mouseOverRect() == true)  {  // If mouse is over square,
    fill(204);                     // change color and  
    port.write('H');               // send an H to indicate mouse is over square 
  } else {                         // If mouse is not over square,
    fill(0);                       // change color and
    port.write('L');               // send an L otherwise
  } 
  rect(50, 50, 100, 100);          // Draw a square 
} 


boolean mouseOverRect() {        // Test if mouse is over square 
  return ((mouseX >= 50) &amp;&amp; (mouseX <= 150) && (mouseY >= 50) &amp;&amp; (mouseY <= 150)); 
} 
</pre>
<br />
<hr />
<br />
<em>Example 4A: Controlling a servomotor(Wiring/Arduino)</em>
<br /> 
<br /> 
<img src="imgs/fg39-16.svg" style= "width: 687px; height: 297px">
<br /> 
<pre>
// Read data from the serial port and set the position of a servomotor 
// according to the value

Servo myservo;                   // Create servo object to control a servo
int servoPin = 4;                // Connect yellow servo wire to digital I/O pin 4 
int val = 0;                     // Data received from the serial port

void setup() {
  myservo.attach(servoPin);      // Attach the servo to the PWM pin
  Serial.begin(9600);    	       // Start serial communication at 9600 bps
}

void loop() {
  if (Serial.available()) {      // If data is available to read,
    val = Serial.read();         // read it and store it in val 
  } 
  myservo.write(val);            // Set the servo position
  delay(15);                     // Wait for the servo to get there
}
</pre>
<br /> 
<br /> 
<em>Example 4B: Controlling a servomotor (Processing)</em>
<pre>
// Write data to the serial port according to the mouseX value

import processing.serial.*;
 
Serial port;                          // Create object from Serial class
float mx = 0.0;

void setup() { 
  size(200, 200); 
  noStroke(); 
  frameRate(10); 
  // Open the port that the board is connected to and use the same speed (9600 bps) 
  port = new Serial(this, 9600); 
} 

void draw() {   
  background(0);			    // Clear background 
  fill(204);				    // Set fill color 
  rect(40, height/2-15, 120, 25);	    // Draw square

  float dif = mouseX - mx;
  if (abs(dif) > 1.0) {
    mx += dif/4.0;
  }
  mx = constrain(mx, 50, 149);                // Keeps marker on the screen
  noStroke();
  fill(255);
  rect(50, (height/2)-5, 100, 5);  
  fill(204, 102, 0);
  
  rect(mx-2, height/2-5, 4, 5);               // Draw the position marker
  int angle = int(map(mx, 50, 149, 0, 180));  // Scale the value to the range 0-180
  //print(angle + " ");	                    // Print the current angle (debug)
  port.write(angle);	                    // Write the angle to the serial port
}
</pre>
<br />
<hr />
<br />
<em>Example 5A: Turning a DC Motor on and off (Wiring/Arduino)</em>
<br /> 
<br /> 
<img src="imgs/fg39-17.svg" style= "width: 687px; height: 369px">
<br /> 
<br /> 
<pre>
// Read data from the serial and turn a DC motor on or off according to the value

char val;                              // Data received from the serial port
int motorpin = 0;     // Wiring: Connect L293D Pin En1 connected to Pin PWM 0          
// int motorpin = 9;  // Arduino: Connect L293D Pin En1 to Pin PWM 9
 
void setup() { 
  Serial.begin(9600);                  // Start serial communication at 9600 bps 
} 
 
void loop() { 
  if (Serial.available()) {            // If data is available,  
    val = Serial.read();               // read it and store it in val</em> 
  } 
  if (val == 'H') {                    // If 'H' was received, 
    analogWrite(motorpin, 125);        // turn the motor on at medium speed 
  } else { 			             // If 'H' was not received
    analogWrite(motorpin, 0);          // turn the motor off 
  } 
  delay(100);                          // Wait 100 milliseconds for next reading
}
</pre>
<br /> 
<br /> 
<em>Example 5B: Turning a DC motor on and off (Processing)</em>
<pre>
// Write data to the serial port according to the status of a button controlled 
// by the mouse 

import processing.serial.*;

Serial port;                           // Create serial port object 
boolean rectOver = false;      	
int rectX, rectY;                      // Position of square button
int rectSize = 100;                    // Diameter of rect
color rectColor;
boolean buttonOn = false;              // Status of the button
void setup() {
  size(200, 200); 
  noStroke(); 
  frameRate(10);
  rectColor = color(100);
  rectX = width/2 - rectSize/2;
  rectY = height/2 - rectSize/2;
  // Open the port that the board is connected to and use the same speed (9600 bps)
  port = new Serial(this, 9600); 
} 

void draw() {   
  update(mouseX, mouseY);
  background(0);                 // Clear background to black
  fill(rectColor);            	         
  rect(rectX, rectY, rectSize, rectSize);  
} 

void update(int x, int y) {
  if (overRect(rectX, rectY, rectSize, rectSize) == true) {
    rectOver = true;
  } else {
    rectOver = false;
  }
}

void mouseReleased() {
  if (rectOver == true) {
    if (buttonOn == true) {
      rectColor = color(100);
      buttonOn = false;
      port.write('L');           // Send an L to indicate button is OFF
    } else {
      rectColor = color(180);
      buttonOn = true;
      port.write('H');           // Send an H to indicate button is ON 
    }
  }
}

boolean overRect(int x, int y, int width, int height) {
  if ((mouseX >= x) &amp;&amp; (mouseX &lt;= x+width) &amp;&amp; 
      (mouseY >= y) &amp;&amp; (mouseY &lt;= y+height)) {
    return true;
  } else {
    return false;
  }
}
</pre>
</p>
<hr />
<br />
<br />
<!--
<p>
<h3>Resources</h3>
<em>Vendors and manufacturers</em>
<br />
<a href="http://www.acroname.com">Acroname</a>. Robotics components distributor and BrainStem creator.
<br />
<a href="http://www.allelectronics.com">All Electronics</a>. Surplus electronics distributor.
<br /> 
<a href="http://www.analog.com">Analog Devices</a>. Electronics components (sensors, A/D converters, etc.) manufacturer.
<br /> 
<a href="http://www.arduino.cc">Arduino</a>. Prototyping toolkit.
<br /> 
<a href="http://www.digikey.com">Digi-Key</a>. Large electronics parts distributor.
<br /> 
<a href="http://www.jameco.com">Jameco</a>. Large electronics parts distributor.
<br /> 
<a href="http://mindstorms.lego.com">LEGO Mindstorms</a>. Programmable electronics from LEGO.
<br /> 
<a href="http://www.mcmaster.com">McMaster-Carr</a>. Extensive selection of hardware and construction supplies. 
<br /> 
<a href="http://www.microchip.com">Microchip</a>. Creator of PICmicro microcontrollers.
<br /> 
<a href="http://www.servocity.com">Servocity</a>. Servomotor distributor.
<br /> 
<a href="http://www.smallparts.com">Small Parts</a>. Hardware for researchers and developers.
<br /> 
<a href="http://www.solarbotics.com">Solarbotics</a>. Distributor for solar-powered robotics kits and components.
<br /> 
<a href="http://www.sparkfun.com">Spark Fun Electronics</a>.
<br /> 
<a href="http://wiring.org.co">Wiring</a>. Prototyping environment and toolkit.
<br />
<br /> 
<em>Online resources</em>
<br /> 
Buxton, Bill. <a href="http://www.billbuxton.com/InputSources.html">List of input devices</a>.
<br />
Igoe, Tom. <a href="http://tigoe.net/pcomp">Physical computing resources</a>.
<br />
<a href="http://www.findchips.com">FindChips</a>. Electronic components search engine.
<br />
<a href="http://www.instructables.com">Instructables</a>. Step-by-step instructions for building projects.
<br />
Haque, Usman, and Adam Somlai-Fischer. <a href="http://lowtech.propositions.org.uk">Low-tech sensors and actuators</a>.
<br />
<a href="http://www.makezine.com">Make magazine</a>. Do-it-yourself technology.
<br />
<a href="http://www.opencircuits.com">Open Circuits</a>. Wiki for electronics projects, components, and techniques.
<br />
O’Sullivan, Dan. <a href="http://itp.nyu.edu/~dbo3/physical/physical.html">Physical computing resources</a>.
<br />
<a href="http://en.wikipedia.org/wiki/RS-232">RS-232 Serial</a>. Data protocol description.
<br />
<br />
<em>Texts</em>
<br />
Banzi, Massimo. <em>Getting Started with Arduino</em>. Make, 2011.
<br />
Burnham, Jack. <em>Beyond Modern Sculpture</em>. George Braziller, 1968.
<br />
Horowitz, Paul, and Winfield Hill. <em>The Art of Electronics</em>. Second edition. Cambridge University Press, 1989.
<br />
Hultén, K. G. Pontus. <em>The Machine: As Seen at the End of the Mechanical Age</em>. The Museum of Modern Art, 1968.
<br />
Fraden, Jacob. <em>Handbook of Modern Sensors: Physics, Designs, and Applications</em>. Springer-Verlag, 1996.
<br /> 
Igoe, Tom. <em>Making Things Talk: Using Sensors, Networks, and Arduino to See, Hear, and Feel Your World.</em> Make, 2011.
<br /> 
Margolis, Michael. <em>Arduino Cookbook</em>. O’Reilly Media, 2011.
<br />
Mims, Forrest M. III. <em>Getting Started in Electronics</em>. Second edition. Radio Shack, 1998.
<br /> 
Mims, Forrest M. III. <em>Timer, Op Amp, and Optoelectronic Circuits and Projects</em>. Radio Shack, 2000.
<br /> 
O’Sullivan, Dan, and Tom Igoe. <em>Physical Computing: Sensing and Controlling the Physical World with Computers</em>. Thomson Course Technology PTR, 2004.
<br /> 
Petzold, Charles. <em>Code: The Hidden Language of Computer Hardware and Software</em>. Microsoft Press, 2000.
<br /> 
Platt, Charles. <em>Make: Electronics</em>. Make, 2009.
<br /> 
Scherz, Paul. <em>Practical Electronics for Inventors</em>. McGraw-Hill, 2000.
<br />
<br />
<em>Artists, designers, institutions</em>
<br />
Dunne, Anthony, and Fiona Raby. <em>Design Noir</em>. Birkhäuser, 2001.
<br /> 
<a href="http://bureauit.org">Bureau of Inverse Technology</a>
<br />
<a href="http://www.kenfeingold.com">Feingold, Ken</a> 
<br />
Hawkinson, Tim. <em>Tim Hawkinson</em>. Harry N. Abrams, 2004.
<br /> 
<a href=" http://www.ideo.com">IDEO</a>. Design firm.
<br />
<a href="http://www.design-interactions.rca.ac.uk/">Design Interactions</a>. Royal College of Art. MFA program. 
<br />
<a href="http://itp.nyu.edu/itp">Interactive Telecommunication Program</a>. New York University. MFA program. 
<br />
<a href="http://www.mr-jones.org">Jones, Crispin</a>
<br />
<a href="http://www.vector-scan.com">Kuwakubo, Ryota</a>
<br /> 
<a href="http://www.maywadenki.com">Maywa Denki</a>
<br />
Paik, Nam June. <em>The Worlds of Nam June Paik</em>. Solomon R. Guggenheim Foundation, 2000.
<br /> 
<a href="http://tangible.media.mit.edu">Tangible Media Group</a>, MIT Media Lab.
<br />
<a href="http://www.bitforms.com/artist_vogel.html">Vogel, Peter</a>
</p>-->
</p>

</td>
       </tr>
 </table>